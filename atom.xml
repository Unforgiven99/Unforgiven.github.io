<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Unforgiven</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://unforgiven99.github.io/"/>
  <updated>2019-05-18T08:21:31.023Z</updated>
  <id>http://unforgiven99.github.io/</id>
  
  <author>
    <name>Unforgiven</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并查集</title>
    <link href="http://unforgiven99.github.io/2019/05/18/Disjoint-Set/"/>
    <id>http://unforgiven99.github.io/2019/05/18/Disjoint-Set/</id>
    <published>2019-05-18T07:20:42.000Z</published>
    <updated>2019-05-18T08:21:31.023Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了并查集的原理以及代码实现。<br><a id="more"></a></p><h2 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h2><p>并查集是一种用来管理元素分组情况的数据结构，可以高效地执行如下操作：</p><ul><li>查询元素a和元素b是否属于同一组</li><li>合并元素a和元素b所在的组</li></ul><p>并查集中每个元素对应一个节点，每个组对应一棵树。</p><p><strong>注意：并查集中的元素均是有联系的，即只要有关联的元素就会被分到同一集合中</strong></p><h3 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h3><p>将一个组的根向另一个组的根连边即可。</p><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><p>从查询节点沿着树往上走，查询包含该节点的树的根，如果两个节点的根相同，则属于同一组。</p><h3 id="优化——路径压缩"><a href="#优化——路径压缩" class="headerlink" title="优化——路径压缩"></a>优化——路径压缩</h3><p>如果高的树不断向低的树合并，那么就会发生退化，近似变成一个链表，为了避免这种情况，采取一些优化操作进行路径压缩。</p><ul><li>对于每棵树，记录这棵树的高度</li><li>合并时，高度小的树向高度大的树连边</li><li>在查询过程中向上经过的所有节点，都改为直接连到根节点</li></ul><h2 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h2><h3 id="食物链（POJ-No-1182）"><a href="#食物链（POJ-No-1182）" class="headerlink" title="食物链（POJ No.1182）"></a>食物链（POJ No.1182）</h3><p>Description</p><p>动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B，B吃C，C吃A。现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。<br>有人用两种说法对这N个动物所构成的食物链关系进行描述：<br>第一种说法是”1 X Y”，表示X和Y是同类。<br>第二种说法是”2 X Y”，表示X吃Y。<br>此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。<br>1） 当前的话与前面的某些真的话冲突，就是假话；<br>2） 当前的话中X或Y比N大，就是假话；<br>3） 当前的话表示X吃X，就是假话。<br>你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。</p><p>Input</p><p>第一行是两个整数N和K，以一个空格分隔。<br>以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。<br>若D=1，则表示X和Y是同类。<br>若D=2，则表示X吃Y。</p><p>Output</p><p>只有一个整数，表示假话的数目。</p><p>这道题是一道经典的并查集题目，该题难点在于元素之间的关系有两种：同类和捕食。不能想当然地按照A、B、C三种动物来分类，因为并查集中只要有联系就会被分为一组，如何巧妙地维护这两种关系是解决问题的关键。</p><h4 id="思路一：改变元素"><a href="#思路一：改变元素" class="headerlink" title="思路一：改变元素"></a>思路一：改变元素</h4><p>一个动物只有三种情况：A、B、C，既然根据所给信息无法确定某一动物到底属于哪一种动物，那么不妨将这三种情况均记录下来，即对于每只动物i创建三个元素i-A，i-B，i-C，并用这3*N个元素建立并查集，并查集里的每一个组都代表组内所有元素代表的情况都同时发生或不发生，若x和y属于同一种类，合并x-A和y-A、x-B和y-B、x-C和y-C;若x吃y，则合并x-A和y-B、x-B和y-C、x-C和y-A。在合并之前先判断是否会产生矛盾即可判断当前信息是否正确。</p><p>实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 5000*3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_K 100000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line"><span class="keyword">int</span> T[MAX_K], X[MAX_K], Y[MAX_K];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> par[MAX_N];</span><br><span class="line"><span class="keyword">int</span> rank[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        par[i] = i;</span><br><span class="line">        rank[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (par[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> par[x] = find(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = find(x);</span><br><span class="line">    y = find(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (rank[x] &lt; rank[y]) &#123;</span><br><span class="line">        par[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        par[y] = x;</span><br><span class="line">        <span class="keyword">if</span> (rank[x] == rank[y]) rank[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;N, &amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;T[i], &amp;X[i], &amp;Y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    init(N * <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = T[i];</span><br><span class="line">        <span class="keyword">int</span> x = X[i] - <span class="number">1</span>, y = Y[i] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || N &lt;= x || y &lt; <span class="number">0</span> || N &lt;= y) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (same(x, y + N) || same(x, y + <span class="number">2</span> * N)) ans++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                unite(x, y);</span><br><span class="line">                unite(x + N, y + N);</span><br><span class="line">                unite(x + <span class="number">2</span> * N, y + <span class="number">2</span> * N);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (same(x, y) || same(x, y + <span class="number">2</span> * N)) ans++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                unite(x, y + N);</span><br><span class="line">                unite(x + N, y + <span class="number">2</span> * N);</span><br><span class="line">                unite(x + <span class="number">2</span> * N, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路二：带权并查集"><a href="#思路二：带权并查集" class="headerlink" title="思路二：带权并查集"></a>思路二：带权并查集</h4><p>维护的两种关系可以用节点上所带的权值来表示，我们可以把这2个元素之间的关系量转化为一个偏移量，用一个relation[N]数组来记录每个节点到其根节点的偏移量:</p><ul><li>x-&gt;y 偏移量0时 x和y同类</li><li>x-&gt;y 偏移量1时 x被y吃</li><li>x-&gt;y 偏移量2时 x吃y</li></ul><p>只需要在查询和合并节点时，更新节点到根节点的偏移量即可。只要注意，更新偏移量类似向量加减法，具有方向性。</p><p>实现代码略。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了并查集的原理以及代码实现。&lt;br&gt;
    
    </summary>
    
      <category term="并查集" scheme="http://unforgiven99.github.io/categories/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    
      <category term="并查集" scheme="http://unforgiven99.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>DFS &amp; BFS</title>
    <link href="http://unforgiven99.github.io/2019/05/17/DFS-BFS/"/>
    <id>http://unforgiven99.github.io/2019/05/17/DFS-BFS/</id>
    <published>2019-05-17T07:02:25.000Z</published>
    <updated>2019-05-18T07:48:49.755Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了穷竭搜索的两个算法DFS和BFS及它们的实现代码。<br><a id="more"></a></p><h2 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h2><p>深度优先搜索（DFS）是从某个状态开始，不断地转移到下一个状态，直到“底部”，然后回退到上一个状态，继续搜索该状态可转移的其他状态，不断重复以上过程，得到最终解。一般采用递归函数实现。</p><p>宽度优先搜索（BFS）是先搜索离当前状态最近的状态，再搜索次近一点的状态……深度优先搜索类似利用栈计算的方式，将栈顶能转移的状态入栈，直到无可转移状态后再出栈；宽度优先搜索则类似利用队列计算的方式，将当前状态可转移的最近的状态依次加入队列，再从队列前端取出状态，然后将该状态可以转移但未访问过的状态加入队列……其代码实现也正是利用了C++中的queue。</p><h2 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h2><h3 id="Lake-Counting（POJ-No-2386）"><a href="#Lake-Counting（POJ-No-2386）" class="headerlink" title="Lake Counting（POJ No.2386）"></a>Lake Counting（POJ No.2386）</h3><p>Description</p><p>Due to recent rains, water has pooled in various places in Farmer John’s field, which is represented by a rectangle of N x M (1 &lt;= N &lt;= 100; 1 &lt;= M &lt;= 100) squares. Each square contains either water (‘W’) or dry land (‘.’). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors. </p><p>Input</p><ul><li>Line 1: Two space-separated integers: N and M </li><li>Lines 2..N+1: M characters per line representing one row of Farmer John’s field. Each character is either ‘W’ or ‘.’. The characters do not have spaces between them.</li></ul><p>Output</p><ul><li>Line 1: The number of ponds in Farmer John’s field.</li></ul><p>只要从任意W开始，用.代替，穷竭搜索其邻接的W，并用.代替，直到图中不存在W为止，此时调用DFS搜索的次数就是答案。</p><p>实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">char</span> field[MAX_N + <span class="number">1</span>][MAX_M + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    field[x][y] = <span class="string">'.'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> dx = <span class="number">-1</span>; dx &lt;= <span class="number">1</span>; dx++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dy = <span class="number">-1</span>; dy &lt;= <span class="number">1</span>; dy++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = x + dx, ny = y + dy;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= nx &amp;&amp; nx &lt; N &amp;&amp; <span class="number">0</span> &lt;= ny &amp;&amp; ny &lt; M &amp;&amp; field[nx][ny] == <span class="string">'W'</span>) dfs(nx, ny);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;field[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (field[i][j] == <span class="string">'W'</span>) &#123;</span><br><span class="line">                dfs(i, j);</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迷宫的最短路径"><a href="#迷宫的最短路径" class="headerlink" title="迷宫的最短路径"></a>迷宫的最短路径</h3><p>给定一个大小为N*M的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四格的通道移动。请求出从起点到终点所需的最小步数。</p><p>题目要求最短路径，很容易想到用BFS，因为它最先搜索距离最近的点，我们只需要从起点开始搜索，用一个d[N][M]数组把各点到起点的距离保存起来，就能求出起点到终点的最短距离。</p><p>实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 100</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;  <span class="comment">//4个方向移动的向量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> maze[MAX_N + <span class="number">1</span>][MAX_M + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> sx, sy;</span><br><span class="line"><span class="keyword">int</span> gx, gy;</span><br><span class="line"><span class="keyword">int</span> d[MAX_N + <span class="number">1</span>][MAX_M + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;P&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) fill(d[i], d[i] + M, INF);</span><br><span class="line">    que.push(P(sx, sy));</span><br><span class="line">    d[sx][sy] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (que.size()) &#123;</span><br><span class="line">        P p = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">if</span> (p.first == gx &amp;&amp; p.second == gy) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = p.first + dx[i], ny = p.second + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= nx &amp;&amp; nx &lt; N &amp;&amp; <span class="number">0</span> &lt;= ny &amp;&amp; ny &lt; M &amp;&amp; maze[nx][ny] != <span class="string">'#'</span> &amp;&amp; d[nx][ny] == INF) &#123;</span><br><span class="line">                que.push(P(nx, ny));</span><br><span class="line">                d[nx][ny] = d[p.first][p.second] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[gx][gy];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;maze[i][j]);</span><br><span class="line">            <span class="keyword">if</span> (maze[i][j] == <span class="string">'S'</span>) &#123;</span><br><span class="line">                sx = i;</span><br><span class="line">                sy = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maze[i][j] == <span class="string">'G'</span>) &#123;</span><br><span class="line">                gx = i;</span><br><span class="line">                gy = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = bfs();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了穷竭搜索的两个算法DFS和BFS及它们的实现代码。&lt;br&gt;
    
    </summary>
    
      <category term="DFS&amp;BFS" scheme="http://unforgiven99.github.io/categories/DFS-BFS/"/>
    
    
      <category term="DFS" scheme="http://unforgiven99.github.io/tags/DFS/"/>
    
      <category term="BFS" scheme="http://unforgiven99.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://unforgiven99.github.io/2019/05/16/bp/"/>
    <id>http://unforgiven99.github.io/2019/05/16/bp/</id>
    <published>2019-05-16T09:33:18.000Z</published>
    <updated>2019-05-18T07:32:37.533Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说，动态规划即记忆化搜索。本文简单介绍了动态规划的原理及代码实现。<br><a id="more"></a></p><h2 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h2><p>对于某些问题，进行穷竭搜索并不是最优解，某些节点会被多次计算，这导致时间、空间复杂度的增加。动态规划就是用来将这些结果记录下来，能大大降低复杂度的算法。要用动态规划解决问题必须先对问题的状态进行合理的假设，建立状态转移方程，确定边界。</p><p>一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！</p><ul><li><p>每个阶段只有一个状态-&gt;递推；</p></li><li><p>每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心；</p></li><li><p>每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索；</p></li><li><p>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。</p></li></ul><h2 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h2><h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><p>有n个重量和价值分别为w<sub>i</sub>，v<sub>i</sub>的物品。从这些物品中挑选出总重量不超过W的物品，求所有挑选方案中价值总和的最大值。</p><p>这里，我们可以定义：</p><p>$$ dp[i+1][j]：从0到i这i+1个物品中选出重量不超过j的物品时总价值的最大值 $$</p><p>因此，两个状态的转移就有两种可能：选第i个物品；不选第i个物品。得到状态转移方程：</p><p>$$<br>dp[i+1][j] =<br>\begin{cases}dp[i][j] &amp; (j&lt;w[i]) \\<br>max(dp[i][j],dp[i][j-w[i]]+v[i]) &amp; (其他)<br>\end{cases}<br>$$</p><p>实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_W 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">1</span>][MAX_W + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, W;</span><br><span class="line">    <span class="keyword">int</span> w[MAX_N + <span class="number">1</span>], v[MAX_N + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;w[i], &amp;v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;W);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= W; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; w[i]) dp[i + <span class="number">1</span>][j] = dp[i][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i + <span class="number">1</span>][j] = max(dp[i][j], dp[i][j - w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[n][W]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单来说，动态规划即记忆化搜索。本文简单介绍了动态规划的原理及代码实现。&lt;br&gt;
    
    </summary>
    
      <category term="dp" scheme="http://unforgiven99.github.io/categories/dp/"/>
    
    
      <category term="dp" scheme="http://unforgiven99.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://unforgiven99.github.io/2019/05/14/hello-world/"/>
    <id>http://unforgiven99.github.io/2019/05/14/hello-world/</id>
    <published>2019-05-14T14:35:48.943Z</published>
    <updated>2017-10-28T00:39:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
