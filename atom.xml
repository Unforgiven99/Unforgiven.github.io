<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Unforgiven</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://unforgiven99.github.io/"/>
  <updated>2019-05-21T13:25:59.588Z</updated>
  <id>http://unforgiven99.github.io/</id>
  
  <author>
    <name>Unforgiven</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Segment Tree</title>
    <link href="http://unforgiven99.github.io/2019/05/21/Segment-Tree/"/>
    <id>http://unforgiven99.github.io/2019/05/21/Segment-Tree/</id>
    <published>2019-05-21T07:17:20.000Z</published>
    <updated>2019-05-21T13:25:59.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h2><p>线段树是一种用来处理区间的数据结构。线段树是一棵完美二叉树（所有叶子深度都相同，并且每个节点要么是叶子，要么是有2个儿子的树），树上的每个节点都维护一个区间。根维护的是整个区间，每个节点维护的是父亲节点的区间二等分后的其中一个区间。</p><p>下面以实现了Range Minimum Query(RMQ)操作的线段树为例。</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>给定s和t，查询a<sub>s</sub>，a<sub>s+1</sub>，…，a<sub>t</sub>的最小值。只需要从根节点递归处理：</p><ul><li>如果所查询的区间和当前节点对应的区间没有交集，返回不影响答案的一个值。</li><li>如果所查询的区间包含了当前节点对应的区间，返回当前节点的值。</li><li>否则，对两个儿子节点递归，返回其中的最小值。</li></ul><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>给定i和x，把a<sub>i</sub>的值改为x。可以从最下面的节点往上不断更新，更新为两个儿子节点的最小值即可。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1</span> &lt;&lt; <span class="number">17</span>;</span><br><span class="line"><span class="keyword">int</span> n, dat[<span class="number">2</span> * MAX_N - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; _n) n *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n - <span class="number">1</span>; i++) dat[i] = INT_MAX; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    k += n - <span class="number">1</span>;</span><br><span class="line">    dat[k] = a;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        k = (k - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        dat[k] = min(dat[k * <span class="number">2</span> + <span class="number">1</span>], dat [k * <span class="number">2</span> + <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= a || b &lt;= l) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= l &amp;&amp; r &lt;= b) <span class="keyword">return</span> dat[k];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> vl = query(a, b, <span class="number">2</span> * k + <span class="number">1</span>, l, (l + r) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> vr = query(a, b, <span class="number">2</span> * k + <span class="number">2</span>, (l + r) / <span class="number">2</span>, r);</span><br><span class="line">        <span class="keyword">return</span> min(vl, vr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h2><h3 id="Crane（POJ-2991）"><a href="#Crane（POJ-2991）" class="headerlink" title="Crane（POJ 2991）"></a>Crane（POJ 2991）</h3><p>Description</p><p>ACM has bought a new crane (crane – jeřáb) . The crane consists of n segments of various lengths, connected by flexible joints. The end of the i-th segment is joined to the beginning of the i + 1-th one, for 1 ≤ i &lt; n. The beginning of the first segment is fixed at point with coordinates (0, 0) and its end at point with coordinates (0, w), where w is the length of the first segment. All of the segments lie always in one plane, and the joints allow arbitrary rotation in that plane. After series of unpleasant accidents, it was decided that software that controls the crane must contain a piece of code that constantly checks the position of the end of crane, and stops the crane if a collision should happen. </p><p>Your task is to write a part of this software that determines the position of the end of the n-th segment after each command. The state of the crane is determined by the angles between consecutive segments. Initially, all of the angles are straight, i.e., 180o. The operator issues commands that change the angle in exactly one joint. </p><p>Input</p><p>The input consists of several instances, separated by single empty lines. </p><p>The first line of each instance consists of two integers 1 ≤ n ≤10 000 and c 0 separated by a single space – the number of segments of the crane and the number of commands. The second line consists of n integers l1,…, ln (1 li 100) separated by single spaces. The length of the i-th segment of the crane is li. The following c lines specify the commands of the operator. Each line describing the command consists of two integers s and a (1 ≤ s &lt; n, 0 ≤ a ≤ 359) separated by a single space – the order to change the angle between the s-th and the s + 1-th segment to a degrees (the angle is measured counterclockwise from the s-th to the s + 1-th segment). </p><p>Output</p><p>The output for each instance consists of c lines. The i-th of the lines consists of two rational numbers x and y separated by a single space – the coordinates of the end of the n-th segment after the i-th command, rounded to two digits after the decimal point. </p><p>The outputs for each two consecutive instances must be separated by a single empty line.</p><p>可以将线段转化为向量来考虑，于是求终点坐标变成了将所有线段的向量求和，当执行指令时，该线段之后的所有线段向量均需要旋转角度，这些都涉及区间操作，因此考虑使用线段树来实现。每个节点表示一段连续的线段构成的集合，并且维护两个值：</p><ul><li>该节点包含的所有线段连接起来构成的向量坐标</li><li>该节点的右儿子在和左儿子连接之前需要旋转的角度</li></ul><p>实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_C 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ST_SIZE = (<span class="number">1</span> &lt;&lt; <span class="number">15</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, C;</span><br><span class="line"><span class="keyword">int</span> L[MAX_N];</span><br><span class="line"><span class="keyword">int</span> S[MAX_C], A[MAX_N];</span><br><span class="line"><span class="keyword">double</span> vx[ST_SIZE], vy[ST_SIZE];</span><br><span class="line"><span class="keyword">double</span> ang[ST_SIZE];</span><br><span class="line"><span class="keyword">double</span> prv[MAX_N];              <span class="comment">//保存每个节点当前角度的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ang[k] = vx[k] = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (r - <span class="number">1</span> == l) vy[k] = L[l];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> chl = <span class="number">2</span> * k + <span class="number">1</span>, chr = <span class="number">2</span> * k + <span class="number">2</span>;</span><br><span class="line">            init(chl, l , (l + r) / <span class="number">2</span>);</span><br><span class="line">            init(chr, (l + r) / <span class="number">2</span> , r);</span><br><span class="line">            vy[k] = vy[chl] + vy[chr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">double</span> a, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= l) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> chl = <span class="number">2</span> * v + <span class="number">1</span>, chr = <span class="number">2</span> * v + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        change(s, a, chl, l, m);</span><br><span class="line">        change(s, a, chr, m, r);</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= m) ang[v] += a;</span><br><span class="line">        <span class="keyword">double</span> s = <span class="built_in">sin</span>(ang[v]), c = <span class="built_in">cos</span>(ang[v]);</span><br><span class="line">        vx[v] = vx[chl] + (c * vx[chr] - s * vy[chr]);</span><br><span class="line">        vy[v] = vy[chl] + (s * vx[chr] + c * vy[chr]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;N, &amp;C) == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;L[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C; i++) <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;S[i], &amp;A[i]);</span><br><span class="line">        init(<span class="number">0</span>, <span class="number">0</span>, N);</span><br><span class="line">        fill(prv, prv + N, M_PI);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = S[i];</span><br><span class="line">            <span class="keyword">double</span> a = A[i] / <span class="number">360.0</span> * <span class="number">2</span> * M_PI;</span><br><span class="line">            change(s, a - prv[s], <span class="number">0</span>, <span class="number">0</span>, N);</span><br><span class="line">            prv[s] = a;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.2f %.2f\n"</span>, vx[<span class="number">0</span>], vy[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原理简介&quot;&gt;&lt;a href=&quot;#原理简介&quot; class=&quot;headerlink&quot; title=&quot;原理简介&quot;&gt;&lt;/a&gt;原理简介&lt;/h2&gt;&lt;p&gt;线段树是一种用来处理区间的数据结构。线段树是一棵完美二叉树（所有叶子深度都相同，并且每个节点要么是叶子，要么是有2个儿子的树
      
    
    </summary>
    
      <category term="线段树" scheme="http://unforgiven99.github.io/categories/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    
      <category term="线段树" scheme="http://unforgiven99.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树问题</title>
    <link href="http://unforgiven99.github.io/2019/05/20/Minimum-Spanning-Tree/"/>
    <id>http://unforgiven99.github.io/2019/05/20/Minimum-Spanning-Tree/</id>
    <published>2019-05-20T06:24:04.000Z</published>
    <updated>2019-05-20T07:02:11.546Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单介绍了最小生成树的Prim和Kruskal算法基本原理及代码实现。<br><a id="more"></a></p><h2 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h2><p>给定一个无向图，如果它的某个子图中任意两个顶点都互相连通并且是一棵树，那么这棵树就叫做生成树。如果边上有权值，那么使得边权值和最小的生成树叫做最小生成树。</p><h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p>Prim算法是一种从某个顶点出发，不断添加边的算法。基本原理是以任意一顶点作为开始作为树T，不断选取T和其他顶点之间相连的最小权值的边，把它加入T中，就可以得到最小生成树了。将T和顶点V相连的边的最小权值记为mincost[v]。当向T中添加顶点u时，更新mincost[v]=min(mincost[v]，边(u，v)的权值)即可。此外，采用堆维护mincost[v]可降低复杂度。</p><p>实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cost[MAX_V][MAX_V];</span><br><span class="line"><span class="keyword">int</span> mincost[MAX_V];</span><br><span class="line"><span class="keyword">bool</span> used[MAX_V];</span><br><span class="line"><span class="keyword">int</span> V;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        mincost[i] = INF;</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mincost[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; V; u++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[u] &amp;&amp; (v == <span class="number">-1</span> || mincost[u] &lt; mincost[v]) v = u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        used[v] = <span class="literal">true</span>;</span><br><span class="line">        res += mincost[v];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; V; u++) &#123;</span><br><span class="line">            mincost[u] = min(mincost[u], cost[v][u]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>Kruskal算法是按照边的权值从小到大遍历，若不产生圈，就把当前边加入生成树中。当把连接顶点u和v的边e加入生成树中，如果u和v不在同一个连通分量里，那么加入e不会产生圈；反之，就会产生圈。采用并查集可以高效判断两点是否属于同一个连通分量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">edge es[MAX_E];</span><br><span class="line"><span class="keyword">int</span> V, E;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> edge&amp; e1, <span class="keyword">const</span> edge&amp; e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e1.cost &lt; e2.cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(es, es + E, cmp);</span><br><span class="line">    init_union_find(V);         <span class="comment">//并查集的初始化</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++) &#123;</span><br><span class="line">        edge e = es[i];</span><br><span class="line">        <span class="keyword">if</span> (!same(e.u, e.v)) &#123;</span><br><span class="line">            unite(e.u, e.v);</span><br><span class="line">            res += e.cost;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单介绍了最小生成树的Prim和Kruskal算法基本原理及代码实现。&lt;br&gt;
    
    </summary>
    
      <category term="最小生成树" scheme="http://unforgiven99.github.io/categories/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
    
      <category term="Prim" scheme="http://unforgiven99.github.io/tags/Prim/"/>
    
      <category term="Kruskal" scheme="http://unforgiven99.github.io/tags/Kruskal/"/>
    
  </entry>
  
  <entry>
    <title>最短路问题</title>
    <link href="http://unforgiven99.github.io/2019/05/19/Shortest-Path/"/>
    <id>http://unforgiven99.github.io/2019/05/19/Shortest-Path/</id>
    <published>2019-05-19T06:31:06.000Z</published>
    <updated>2019-05-19T09:00:28.652Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了最短路的几个算法：Bellman-Ford，Dijkstra，Floyd-Warshall以及个人理解。<br><a id="more"></a></p><h2 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h2><h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><p>Bellman-Ford算法是求单源最短路的算法，基本原理是通过<strong>遍历边</strong>来对路径进行松弛操作，松弛操作的原理：</p><p>记从起点s出发到顶点i的最短距离为d[i]，则下列等式成立：</p><p>$$ d[i] = min{d[j]+(从i到j的边的权值)|e=(j,i)\in E} $$</p><p>实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cost;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">edge es[MAX_E];</span><br><span class="line"><span class="keyword">int</span> d[MAX_V];</span><br><span class="line"><span class="keyword">int</span> V, E;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shortest_path</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) d[i] = INF;</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">bool</span> update = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++) &#123;</span><br><span class="line">            edge e = es[i];</span><br><span class="line">            <span class="keyword">if</span> (d[e.from] != INF &amp;&amp; d[e.to] &gt; d[e.from] + e.cost ) &#123;</span><br><span class="line">                d[e.to] = d[e.from] + e.cost;</span><br><span class="line">                update = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!update) <span class="keyword">break</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果图中存在负圈，则最短路不存在；如果图中不存在从s可达的负圈，那么最短路不会经过同一顶点两次，最短路最多只经过V个顶点，最多通过V-1条边，while循环最多执行V-1次。基于这个性质，我们可以检查图中是否存在负圈。</p><p>实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find_negative_loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; E; j++) &#123;</span><br><span class="line">            edge e = es[j];</span><br><span class="line">            <span class="keyword">if</span> (d[e.to] &gt; d[e.from] + e.cost ) &#123;</span><br><span class="line">                d[e.to] = d[e.from] + e.cost;</span><br><span class="line">                <span class="keyword">if</span> (i == V - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>Dijkstra算法也是一种单源最短路算法，但它只适用于没有负边的图。其基本原理是<strong>遍历点</strong>，先找到最短距离已知的顶点，从该点出发，更新相邻顶点的最短距离，之后不需要再考虑这个最短距离已知的顶点。而最短距离已知的顶点是在未使用过的顶点中距离最小的顶点，这是因为不存在负边，距离不会在之后的更新中变小。</p><p>实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, cost;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> V;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[MAX_V];</span><br><span class="line"><span class="keyword">int</span> d[MAX_V];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;P, <span class="built_in">vector</span>&lt;P&gt;, greater&lt;P&gt; &gt; que;</span><br><span class="line">    fill(d, d + V, INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    que.push(P(<span class="number">0</span>, s));</span><br><span class="line">    <span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">        P p = que.top();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">int</span> v = p.second();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++) &#123;</span><br><span class="line">            edge e = G[v][i];</span><br><span class="line">            <span class="keyword">if</span> (d[e.to] &gt; d[v] + e.cost) &#123;</span><br><span class="line">                d[e.to] = d[v] + e.cost;</span><br><span class="line">                que.push(P(d[e.to], e.to));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Floyd-Warshall算法"><a href="#Floyd-Warshall算法" class="headerlink" title="Floyd-Warshall算法"></a>Floyd-Warshall算法</h3><p>这是求解任意两点间最短路问题的算法。我们考虑计算顶点i到j的最短路径，记i到j且经过顶点0~k的最短路的长度为d[k+1][i][j],利用DP的思想，我们需要找到一个状态转移方程：该路径可分为经过一次k顶点和不经过两种情况。当不经过顶点k，d[k+1][i][j]=d[k][i][j]；经过顶点k时，d[k+1][i][j]=d[k][i][k]+d[k][k][j]。所以，d[k+1][i][j]=min(d[k][i][j]，d[k][i][k]+d[k][k][j])，可以简化成d[i][j]=min(d[i][j]，d[i][k]+d[k][j])。</p><p>实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d[MAX_V][MAX_V];</span><br><span class="line"><span class="keyword">int</span> V;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">warshall_floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; V; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; V; j++) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路径还原"><a href="#路径还原" class="headerlink" title="路径还原"></a>路径还原</h3><p>对于Bellman-Ford和Dijkstra算法，可以采用前趋节点来还原路径，d[j]=d[k]+cost[k][j]中，顶点k就是顶点j的前趋，用prev[j]记录最短路上顶点j的前趋，当路径更新时，更新prev[j]=k即可。</p><p>实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prev[MAX_V];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; get_patch(<span class="keyword">int</span> t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">for</span> (; t != <span class="number">-1</span>; t = prev[t]) path.push_back(t);</span><br><span class="line">    reverse(path.begin(), path.end());</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于Floyd-Warshall算法，可以用path[i][j]记录i到j路径上经过的最后一个点，当路径更新时，更新path[i][j]=path[i][k]即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了最短路的几个算法：Bellman-Ford，Dijkstra，Floyd-Warshall以及个人理解。&lt;br&gt;
    
    </summary>
    
      <category term="最短路" scheme="http://unforgiven99.github.io/categories/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
    
      <category term="Bellman-Ford" scheme="http://unforgiven99.github.io/tags/Bellman-Ford/"/>
    
      <category term="Dijkstra" scheme="http://unforgiven99.github.io/tags/Dijkstra/"/>
    
      <category term="Floyd-Warshall" scheme="http://unforgiven99.github.io/tags/Floyd-Warshall/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://unforgiven99.github.io/2019/05/18/Disjoint-Set/"/>
    <id>http://unforgiven99.github.io/2019/05/18/Disjoint-Set/</id>
    <published>2019-05-18T07:20:42.000Z</published>
    <updated>2019-05-21T07:40:03.159Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了并查集的原理以及代码实现。<br><a id="more"></a></p><h2 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h2><p>并查集是一种用来管理元素分组情况的数据结构，可以高效地执行如下操作：</p><ul><li>查询元素a和元素b是否属于同一组</li><li>合并元素a和元素b所在的组</li></ul><p>并查集中每个元素对应一个节点，每个组对应一棵树。</p><p><strong>注意：并查集中的元素均是有联系的，即只要有关联的元素就会被分到同一集合中</strong></p><h3 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h3><p>将一个组的根向另一个组的根连边即可。</p><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><p>从查询节点沿着树往上走，查询包含该节点的树的根，如果两个节点的根相同，则属于同一组。</p><h3 id="优化——路径压缩"><a href="#优化——路径压缩" class="headerlink" title="优化——路径压缩"></a>优化——路径压缩</h3><p>如果高的树不断向低的树合并，那么就会发生退化，近似变成一个链表，为了避免这种情况，采取一些优化操作进行路径压缩。</p><ul><li>对于每棵树，记录这棵树的高度</li><li>合并时，高度小的树向高度大的树连边</li><li>在查询过程中向上经过的所有节点，都改为直接连到根节点</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> par[MAX_N];</span><br><span class="line"><span class="keyword">int</span> rank[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        par[i] = i;</span><br><span class="line">        rank[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (par[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> par[x] = find(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = find(x);</span><br><span class="line">    y = find(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (rank[x] &lt; rank[y]) &#123;</span><br><span class="line">        par[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        par[y] = x;</span><br><span class="line">        <span class="keyword">if</span> (rank[x] == rank[y]) rank[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h2><h3 id="食物链（POJ-1182）"><a href="#食物链（POJ-1182）" class="headerlink" title="食物链（POJ 1182）"></a>食物链（POJ 1182）</h3><p>Description</p><p>动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B，B吃C，C吃A。现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。<br>有人用两种说法对这N个动物所构成的食物链关系进行描述：<br>第一种说法是”1 X Y”，表示X和Y是同类。<br>第二种说法是”2 X Y”，表示X吃Y。<br>此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。<br>1） 当前的话与前面的某些真的话冲突，就是假话；<br>2） 当前的话中X或Y比N大，就是假话；<br>3） 当前的话表示X吃X，就是假话。<br>你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。</p><p>Input</p><p>第一行是两个整数N和K，以一个空格分隔。<br>以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。<br>若D=1，则表示X和Y是同类。<br>若D=2，则表示X吃Y。</p><p>Output</p><p>只有一个整数，表示假话的数目。</p><p>这道题是一道经典的并查集题目，该题难点在于元素之间的关系有两种：同类和捕食。不能想当然地按照A、B、C三种动物来分类，因为并查集中只要有联系就会被分为一组，如何巧妙地维护这两种关系是解决问题的关键。</p><h4 id="思路一：改变元素"><a href="#思路一：改变元素" class="headerlink" title="思路一：改变元素"></a>思路一：改变元素</h4><p>一个动物只有三种情况：A、B、C，既然根据所给信息无法确定某一动物到底属于哪一种动物，那么不妨将这三种情况均记录下来，即对于每只动物i创建三个元素i-A，i-B，i-C，并用这3*N个元素建立并查集，并查集里的每一个组都代表组内所有元素代表的情况都同时发生或不发生，若x和y属于同一种类，合并x-A和y-A、x-B和y-B、x-C和y-C;若x吃y，则合并x-A和y-B、x-B和y-C、x-C和y-A。在合并之前先判断是否会产生矛盾即可判断当前信息是否正确。</p><p>实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 5000*3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_K 100000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line"><span class="keyword">int</span> T[MAX_K], X[MAX_K], Y[MAX_K];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> par[MAX_N];</span><br><span class="line"><span class="keyword">int</span> rank[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        par[i] = i;</span><br><span class="line">        rank[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (par[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> par[x] = find(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = find(x);</span><br><span class="line">    y = find(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (rank[x] &lt; rank[y]) &#123;</span><br><span class="line">        par[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        par[y] = x;</span><br><span class="line">        <span class="keyword">if</span> (rank[x] == rank[y]) rank[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;N, &amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;T[i], &amp;X[i], &amp;Y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    init(N * <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = T[i];</span><br><span class="line">        <span class="keyword">int</span> x = X[i] - <span class="number">1</span>, y = Y[i] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || N &lt;= x || y &lt; <span class="number">0</span> || N &lt;= y) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (same(x, y + N) || same(x, y + <span class="number">2</span> * N)) ans++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                unite(x, y);</span><br><span class="line">                unite(x + N, y + N);</span><br><span class="line">                unite(x + <span class="number">2</span> * N, y + <span class="number">2</span> * N);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (same(x, y) || same(x, y + <span class="number">2</span> * N)) ans++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                unite(x, y + N);</span><br><span class="line">                unite(x + N, y + <span class="number">2</span> * N);</span><br><span class="line">                unite(x + <span class="number">2</span> * N, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路二：带权并查集"><a href="#思路二：带权并查集" class="headerlink" title="思路二：带权并查集"></a>思路二：带权并查集</h4><p>维护的两种关系可以用节点上所带的权值来表示，我们可以把这2个元素之间的关系量转化为一个偏移量，用一个relation[N]数组来记录每个节点到其根节点的偏移量:</p><ul><li>x-&gt;y 偏移量0时 x和y同类</li><li>x-&gt;y 偏移量1时 x被y吃</li><li>x-&gt;y 偏移量2时 x吃y</li></ul><p>只需要在查询和合并节点时，更新节点到根节点的偏移量即可。只要注意，更新偏移量类似向量加减法，具有方向性。</p><p>实现代码略。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了并查集的原理以及代码实现。&lt;br&gt;
    
    </summary>
    
      <category term="并查集" scheme="http://unforgiven99.github.io/categories/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    
      <category term="并查集" scheme="http://unforgiven99.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>DFS &amp; BFS</title>
    <link href="http://unforgiven99.github.io/2019/05/17/DFS&amp;BFS/"/>
    <id>http://unforgiven99.github.io/2019/05/17/DFS&amp;BFS/</id>
    <published>2019-05-17T07:02:25.000Z</published>
    <updated>2019-05-18T07:48:49.755Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了穷竭搜索的两个算法DFS和BFS及它们的实现代码。<br><a id="more"></a></p><h2 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h2><p>深度优先搜索（DFS）是从某个状态开始，不断地转移到下一个状态，直到“底部”，然后回退到上一个状态，继续搜索该状态可转移的其他状态，不断重复以上过程，得到最终解。一般采用递归函数实现。</p><p>宽度优先搜索（BFS）是先搜索离当前状态最近的状态，再搜索次近一点的状态……深度优先搜索类似利用栈计算的方式，将栈顶能转移的状态入栈，直到无可转移状态后再出栈；宽度优先搜索则类似利用队列计算的方式，将当前状态可转移的最近的状态依次加入队列，再从队列前端取出状态，然后将该状态可以转移但未访问过的状态加入队列……其代码实现也正是利用了C++中的queue。</p><h2 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h2><h3 id="Lake-Counting（POJ-No-2386）"><a href="#Lake-Counting（POJ-No-2386）" class="headerlink" title="Lake Counting（POJ No.2386）"></a>Lake Counting（POJ No.2386）</h3><p>Description</p><p>Due to recent rains, water has pooled in various places in Farmer John’s field, which is represented by a rectangle of N x M (1 &lt;= N &lt;= 100; 1 &lt;= M &lt;= 100) squares. Each square contains either water (‘W’) or dry land (‘.’). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors. </p><p>Input</p><ul><li>Line 1: Two space-separated integers: N and M </li><li>Lines 2..N+1: M characters per line representing one row of Farmer John’s field. Each character is either ‘W’ or ‘.’. The characters do not have spaces between them.</li></ul><p>Output</p><ul><li>Line 1: The number of ponds in Farmer John’s field.</li></ul><p>只要从任意W开始，用.代替，穷竭搜索其邻接的W，并用.代替，直到图中不存在W为止，此时调用DFS搜索的次数就是答案。</p><p>实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">char</span> field[MAX_N + <span class="number">1</span>][MAX_M + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    field[x][y] = <span class="string">'.'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> dx = <span class="number">-1</span>; dx &lt;= <span class="number">1</span>; dx++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dy = <span class="number">-1</span>; dy &lt;= <span class="number">1</span>; dy++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = x + dx, ny = y + dy;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= nx &amp;&amp; nx &lt; N &amp;&amp; <span class="number">0</span> &lt;= ny &amp;&amp; ny &lt; M &amp;&amp; field[nx][ny] == <span class="string">'W'</span>) dfs(nx, ny);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;field[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (field[i][j] == <span class="string">'W'</span>) &#123;</span><br><span class="line">                dfs(i, j);</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迷宫的最短路径"><a href="#迷宫的最短路径" class="headerlink" title="迷宫的最短路径"></a>迷宫的最短路径</h3><p>给定一个大小为N*M的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四格的通道移动。请求出从起点到终点所需的最小步数。</p><p>题目要求最短路径，很容易想到用BFS，因为它最先搜索距离最近的点，我们只需要从起点开始搜索，用一个d[N][M]数组把各点到起点的距离保存起来，就能求出起点到终点的最短距离。</p><p>实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 100</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;  <span class="comment">//4个方向移动的向量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> maze[MAX_N + <span class="number">1</span>][MAX_M + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> sx, sy;</span><br><span class="line"><span class="keyword">int</span> gx, gy;</span><br><span class="line"><span class="keyword">int</span> d[MAX_N + <span class="number">1</span>][MAX_M + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;P&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) fill(d[i], d[i] + M, INF);</span><br><span class="line">    que.push(P(sx, sy));</span><br><span class="line">    d[sx][sy] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (que.size()) &#123;</span><br><span class="line">        P p = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">if</span> (p.first == gx &amp;&amp; p.second == gy) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = p.first + dx[i], ny = p.second + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= nx &amp;&amp; nx &lt; N &amp;&amp; <span class="number">0</span> &lt;= ny &amp;&amp; ny &lt; M &amp;&amp; maze[nx][ny] != <span class="string">'#'</span> &amp;&amp; d[nx][ny] == INF) &#123;</span><br><span class="line">                que.push(P(nx, ny));</span><br><span class="line">                d[nx][ny] = d[p.first][p.second] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[gx][gy];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;maze[i][j]);</span><br><span class="line">            <span class="keyword">if</span> (maze[i][j] == <span class="string">'S'</span>) &#123;</span><br><span class="line">                sx = i;</span><br><span class="line">                sy = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maze[i][j] == <span class="string">'G'</span>) &#123;</span><br><span class="line">                gx = i;</span><br><span class="line">                gy = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = bfs();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了穷竭搜索的两个算法DFS和BFS及它们的实现代码。&lt;br&gt;
    
    </summary>
    
      <category term="DFS&amp;BFS" scheme="http://unforgiven99.github.io/categories/DFS-BFS/"/>
    
    
      <category term="DFS" scheme="http://unforgiven99.github.io/tags/DFS/"/>
    
      <category term="BFS" scheme="http://unforgiven99.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://unforgiven99.github.io/2019/05/16/DP/"/>
    <id>http://unforgiven99.github.io/2019/05/16/DP/</id>
    <published>2019-05-16T09:33:18.000Z</published>
    <updated>2019-05-19T09:00:41.636Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说，动态规划即记忆化搜索。本文简单介绍了动态规划的原理及代码实现。<br><a id="more"></a></p><h2 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h2><p>对于某些问题，进行穷竭搜索并不是最优解，某些节点会被多次计算，这导致时间、空间复杂度的增加。动态规划就是用来将这些结果记录下来，能大大降低复杂度的算法。要用动态规划解决问题必须先对问题的状态进行合理的假设，建立状态转移方程，确定边界。</p><p>一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！</p><ul><li><p>每个阶段只有一个状态-&gt;递推；</p></li><li><p>每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心；</p></li><li><p>每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索；</p></li><li><p>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。</p></li></ul><h2 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h2><h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><p>有n个重量和价值分别为w<sub>i</sub>，v<sub>i</sub>的物品。从这些物品中挑选出总重量不超过W的物品，求所有挑选方案中价值总和的最大值。</p><p>这里，我们可以定义：</p><p>$$ dp[i+1][j]：从0到i这i+1个物品中选出重量不超过j的物品时总价值的最大值 $$</p><p>因此，两个状态的转移就有两种可能：选第i个物品；不选第i个物品。得到状态转移方程：</p><p>$$<br>dp[i+1][j] =<br>\begin{cases}dp[i][j] &amp; (j&lt;w[i]) \\<br>max(dp[i][j],dp[i][j-w[i]]+v[i]) &amp; (其他)<br>\end{cases}<br>$$</p><p>实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_W 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">1</span>][MAX_W + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, W;</span><br><span class="line">    <span class="keyword">int</span> w[MAX_N + <span class="number">1</span>], v[MAX_N + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;w[i], &amp;v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;W);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= W; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; w[i]) dp[i + <span class="number">1</span>][j] = dp[i][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i + <span class="number">1</span>][j] = max(dp[i][j], dp[i][j - w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[n][W]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单来说，动态规划即记忆化搜索。本文简单介绍了动态规划的原理及代码实现。&lt;br&gt;
    
    </summary>
    
      <category term="DP" scheme="http://unforgiven99.github.io/categories/DP/"/>
    
    
      <category term="DP" scheme="http://unforgiven99.github.io/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://unforgiven99.github.io/2019/05/14/hello-world/"/>
    <id>http://unforgiven99.github.io/2019/05/14/hello-world/</id>
    <published>2019-05-14T14:35:48.943Z</published>
    <updated>2017-10-28T00:39:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
