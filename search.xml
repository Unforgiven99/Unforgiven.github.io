<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DFS & BFS]]></title>
    <url>%2F2019%2F05%2F17%2FDFS-BFS%2F</url>
    <content type="text"><![CDATA[本文主要介绍了穷竭搜索的两个算法DFS和BFS及它们的实现代码。 原理简介深度优先搜索（DFS）是从某个状态开始，不断地转移到下一个状态，直到“底部”，然后回退到上一个状态，继续搜索该状态可转移的其他状态，不断重复以上过程，得到最终解。一般采用递归函数实现。 宽度优先搜索（BFS）是先搜索离当前状态最近的状态，再搜索次近一点的状态……深度优先搜索类似利用栈计算的方式，将栈顶能转移的状态入栈，直到无可转移状态后再出栈；宽度优先搜索则类似利用队列计算的方式，将当前状态可转移的最近的状态依次加入队列，再从队列前端取出状态，然后将该状态可以转移但未访问过的状态加入队列……其代码实现也正是利用了C++中的queue。 实例讲解Lake Counting （POJ No.2386）Description Due to recent rains, water has pooled in various places in Farmer John’s field, which is represented by a rectangle of N x M (1 &lt;= N &lt;= 100; 1 &lt;= M &lt;= 100) squares. Each square contains either water (‘W’) or dry land (‘.’). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors. Input Line 1: Two space-separated integers: N and M Lines 2..N+1: M characters per line representing one row of Farmer John’s field. Each character is either ‘W’ or ‘.’. The characters do not have spaces between them. Output Line 1: The number of ponds in Farmer John’s field. 只要从任意W开始，用.代替，穷竭搜索其邻接的W，并用.代替，直到图中不存在W为止，此时调用DFS搜索的次数就是答案。 实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;using namespace std;#define MAX_N 100#define MAX_M 100int N, M;char field[MAX_N + 1][MAX_M + 1];void dfs(int x, int y)&#123; field[x][y] = '.'; for (int dx = -1; dx &lt;= 1; dx++)&#123; for (int dy = -1; dy &lt;= 1; dy++)&#123; int nx = x + dx, ny = y + dy; if (0 &lt;= nx &amp;&amp; nx &lt; N &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; M &amp;&amp; field[nx][ny] == 'W') dfs(nx, ny); &#125; &#125;&#125;int main()&#123; int res = 0; scanf("%d %d", &amp;N, &amp;M); for (int i = 0; i &lt; N; i++)&#123; for (int j = 0; j &lt; M; j++)&#123; scanf("%c", &amp;field[i][j]); &#125; getchar(); &#125; for (int i = 0; i &lt; N; i++)&#123; for (int j = 0; j &lt; M; j++)&#123; if (field[i][j] == 'W')&#123; dfs(i, j); res++; &#125; &#125; &#125; printf("%d\n",res);&#125; 迷宫的最短路径给定一个大小为N*M的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四格的通道移动。请求出从起点到终点所需的最小步数。 题目要求最短路径，很容易想到用BFS，因为它最先搜索距离最近的点，我们只需要从起点开始搜索，用一个d[N][M]数组把各点到起点的距离保存起来，就能求出起点到终点的最短距离。 实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;utility&gt;#include &lt;algorithm&gt;using namespace std;#define MAX_N 100#define MAX_M 100const int INF = 100000000;typedef pair&lt;int, int&gt; P;int dx[4] = &#123;1, 0, -1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;; //4个方向移动的向量char maze[MAX_N + 1][MAX_M + 1];int N, M;int sx, sy;int gx, gy;int d[MAX_N + 1][MAX_M + 1];int bfs()&#123; queue&lt;P&gt; que; for (int i = 0; i &lt; N; i++) fill(d[i], d[i] + M, INF); que.push(P(sx, sy)); d[sx][sy] = 0; while (que.size())&#123; P p = que.front(); que.pop(); if (p.first == gx &amp;&amp; p.second == gy) break; for (int i = 0; i &lt; 4; i++)&#123; int nx = p.first + dx[i], ny = p.second + dy[i]; if (0 &lt;= nx &amp;&amp; nx &lt; N &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; M &amp;&amp; maze[nx][ny] != '#' &amp;&amp; d[nx][ny] == INF)&#123; que.push(P(nx, ny)); d[nx][ny] = d[p.first][p.second] + 1; &#125; &#125; &#125; return d[gx][gy];&#125;int main()&#123; scanf("%d %d", &amp;N, &amp;M); for (int i = 0; i &lt; N; i++)&#123; for (int j = 0; j &lt; M; j++)&#123; scanf("%c", &amp;maze[i][j]); if (maze[i][j] == 'S')&#123; sx = i; sy = j; &#125; if (maze[i][j] == 'G')&#123; gx = i; gy = j; &#125; &#125; getchar(); &#125; int res = bfs(); printf("%d\n",res);&#125;]]></content>
      <categories>
        <category>DFS&amp;BFS</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2019%2F05%2F16%2Fbp%2F</url>
    <content type="text"><![CDATA[简单来说，动态规划即记忆化搜索。 原理简介对于某些问题，进行穷竭搜索并不是最优解，某些节点会被多次计算，这导致时间、空间复杂度的增加。动态规划就是用来将这些结果记录下来，能大大降低复杂度的算法。要用动态规划解决问题必须先对问题的状态进行合理的假设，建立状态转移方程，确定边界。 一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！ 每个阶段只有一个状态-&gt;递推； 每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心； 每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索； 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。 实例讲解01背包问题有n个重量和价值分别为wi，vi的物品。从这些物品中挑选出总重量不超过W的物品，求所有挑选方案中价值总和的最大值。 这里，我们可以定义： $$ dp[i+1][j]：从0到i这i+1个物品中选出重量不超过j的物品时总价值的最大值 $$ 因此，两个状态的转移就有两种可能：选第i个物品；不选第i个物品。得到状态转移方程： $$dp[i+1][j] =\begin{cases}dp[i][j] &amp; (j&lt;w[i]) \\max(dp[i][j],dp[i][j-w[i]]+v[i]) &amp; (其他)\end{cases}$$ 实现代码如下： 12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define MAX_N 100#define MAX_W 10000int dp[MAX_N + 1][MAX_W + 1];int main()&#123; int n, W; int w[MAX_N + 1], v[MAX_N + 1]; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++)&#123; scanf("%d %d", &amp;w[i], &amp;v[i]); &#125; scanf("%d", &amp;W); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt;= W; j++)&#123; if (j &lt; w[i]) dp[i + 1][j] = dp[i][j]; else dp[i + 1][j] = max(dp[i][j], dp[i][j - w[i]] + v[i]); &#125; &#125; printf("%d\n", dp[n][W]);&#125;]]></content>
      <categories>
        <category>dp</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
