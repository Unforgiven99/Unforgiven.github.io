<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[最小生成树问题]]></title>
    <url>%2F2019%2F05%2F20%2FMinimum-Spanning-Tree%2F</url>
    <content type="text"><![CDATA[本文简单介绍了最小生成树的Prim和Kruskal算法基本原理及代码实现。 原理简介给定一个无向图，如果它的某个子图中任意两个顶点都互相连通并且是一棵树，那么这棵树就叫做生成树。如果边上有权值，那么使得边权值和最小的生成树叫做最小生成树。 Prim算法Prim算法是一种从某个顶点出发，不断添加边的算法。基本原理是以任意一顶点作为开始作为树T，不断选取T和其他顶点之间相连的最小权值的边，把它加入T中，就可以得到最小生成树了。将T和顶点V相连的边的最小权值记为mincost[v]。当向T中添加顶点u时，更新mincost[v]=min(mincost[v]，边(u，v)的权值)即可。此外，采用堆维护mincost[v]可降低复杂度。 实现代码如下： 123456789101112131415161718192021222324252627int cost[MAX_V][MAX_V];int mincost[MAX_V];bool used[MAX_V];int V;int prim()&#123; for (int i = 0; i &lt; V; i++) &#123; mincost[i] = INF; used[i] = false; &#125; mincost[0] = 0; int res = 0; while(true) &#123; int v = -1; for (int u = 0; u &lt; V; u++) &#123; if (!used[u] &amp;&amp; (v == -1 || mincost[u] &lt; mincost[v]) v = u; &#125; if (v == -1) break; used[v] = true; res += mincost[v]; for (int u = 0; u &lt; V; u++) &#123; mincost[u] = min(mincost[u], cost[v][u]); &#125; &#125; return res;&#125; Kruskal算法Kruskal算法是按照边的权值从小到大遍历，若不产生圈，就把当前边加入生成树中。当把连接顶点u和v的边e加入生成树中，如果u和v不在同一个连通分量里，那么加入e不会产生圈；反之，就会产生圈。采用并查集可以高效判断两点是否属于同一个连通分量。 1234567891011121314151617181920212223242526struct edge &#123; int u, v, cost;&#125;edge es[MAX_E];int V, E;bool comp(const edge&amp; e1, const edge&amp; e2)&#123; return e1.cost &lt; e2.cost;&#125;int kruskal()&#123; sort(es, es + E, cmp); init_union_find(V); //并查集的初始化 int res = 0; for (int i = 0; i &lt; E; i++) &#123; edge e = es[i]; if (!same(e.u, e.v)) &#123; unite(e.u, e.v); res += e.cost; &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>Prim</tag>
        <tag>Kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路问题]]></title>
    <url>%2F2019%2F05%2F19%2FShortest-Path%2F</url>
    <content type="text"><![CDATA[本文主要介绍了最短路的几个算法：Bellman-Ford，Dijkstra，Floyd-Warshall以及个人理解。 原理简介Bellman-Ford算法Bellman-Ford算法是求单源最短路的算法，基本原理是通过遍历边来对路径进行松弛操作，松弛操作的原理： 记从起点s出发到顶点i的最短距离为d[i]，则下列等式成立： $$ d[i] = min{d[j]+(从i到j的边的权值)|e=(j,i)\in E} $$ 实现代码如下： 123456789101112131415161718192021222324struct edge &#123; int from, to, cost;&#125;;edge es[MAX_E];int d[MAX_V];int V, E;void shortest_path(int s)&#123; for (int i = 0; i &lt; V; i++) d[i] = INF; d[s] = 0; while (true) &#123; bool update = false; for (int i = 0; i &lt; E; i++) &#123; edge e = es[i]; if (d[e.from] != INF &amp;&amp; d[e.to] &gt; d[e.from] + e.cost ) &#123; d[e.to] = d[e.from] + e.cost; update = true; &#125; &#125; if (!update) break; &#125; &#125; 如果图中存在负圈，则最短路不存在；如果图中不存在从s可达的负圈，那么最短路不会经过同一顶点两次，最短路最多只经过V个顶点，最多通过V-1条边，while循环最多执行V-1次。基于这个性质，我们可以检查图中是否存在负圈。 实现代码如下： 1234567891011121314bool find_negative_loop()&#123; memset(d, 0, sizeof(d)); for (int i = 0; i &lt; V; i++) &#123; for (int j = 0; j &lt; E; j++) &#123; edge e = es[j]; if (d[e.to] &gt; d[e.from] + e.cost ) &#123; d[e.to] = d[e.from] + e.cost; if (i == V - 1) return true; &#125; &#125; &#125; return false;&#125; Dijkstra算法Dijkstra算法也是一种单源最短路算法，但它只适用于没有负边的图。其基本原理是遍历点，先找到最短距离已知的顶点，从该点出发，更新相邻顶点的最短距离，之后不需要再考虑这个最短距离已知的顶点。而最短距离已知的顶点是在未使用过的顶点中距离最小的顶点，这是因为不存在负边，距离不会在之后的更新中变小。 实现代码如下： 12345678910111213141516171819202122232425262728typedef pair&lt;int, int&gt; P;struct edge &#123; int to, cost;&#125;;int V;vector&lt;edge&gt; G[MAX_V];int d[MAX_V];void dijkstra(int s)&#123; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; que; fill(d, d + V, INF); d[s] = 0; que.push(P(0, s)); while(!que.empty()) &#123; P p = que.top(); que.pop(); int v = p.second(); for (int i = 0; i &lt; G[v].size(); i++) &#123; edge e = G[v][i]; if (d[e.to] &gt; d[v] + e.cost) &#123; d[e.to] = d[v] + e.cost; que.push(P(d[e.to], e.to)); &#125; &#125; &#125;&#125; Floyd-Warshall算法这是求解任意两点间最短路问题的算法。我们考虑计算顶点i到j的最短路径，记i到j且经过顶点0~k的最短路的长度为d[k+1][i][j],利用DP的思想，我们需要找到一个状态转移方程：该路径可分为经过一次k顶点和不经过两种情况。当不经过顶点k，d[k+1][i][j]=d[k][i][j]；经过顶点k时，d[k+1][i][j]=d[k][i][k]+d[k][k][j]。所以，d[k+1][i][j]=min(d[k][i][j]，d[k][i][k]+d[k][k][j])，可以简化成d[i][j]=min(d[i][j]，d[i][k]+d[k][j])。 实现代码如下： 1234567891011int d[MAX_V][MAX_V];int V;void warshall_floyd()&#123; for (int k = 0; k &lt; V; k++) &#123; for (int i = 0; i &lt; V; i++) &#123; for (int j = 0; j &lt; V; j++) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); &#125; &#125;&#125; 路径还原对于Bellman-Ford和Dijkstra算法，可以采用前趋节点来还原路径，d[j]=d[k]+cost[k][j]中，顶点k就是顶点j的前趋，用prev[j]记录最短路上顶点j的前趋，当路径更新时，更新prev[j]=k即可。 实现代码如下： 123456789int prev[MAX_V];vector&lt;int&gt; get_patch(int t)&#123; vector&lt;int&gt; path; for (; t != -1; t = prev[t]) path.push_back(t); reverse(path.begin(), path.end()); return path;&#125; 对于Floyd-Warshall算法，可以用path[i][j]记录i到j路径上经过的最后一个点，当路径更新时，更新path[i][j]=path[i][k]即可。]]></content>
      <categories>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>Bellman-Ford</tag>
        <tag>Dijkstra</tag>
        <tag>Floyd-Warshall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2019%2F05%2F18%2FDisjoint-Set%2F</url>
    <content type="text"><![CDATA[本文主要介绍了并查集的原理以及代码实现。 原理简介并查集是一种用来管理元素分组情况的数据结构，可以高效地执行如下操作： 查询元素a和元素b是否属于同一组 合并元素a和元素b所在的组 并查集中每个元素对应一个节点，每个组对应一棵树。 注意：并查集中的元素均是有联系的，即只要有关联的元素就会被分到同一集合中 合并操作将一个组的根向另一个组的根连边即可。 查询操作从查询节点沿着树往上走，查询包含该节点的树的根，如果两个节点的根相同，则属于同一组。 优化——路径压缩如果高的树不断向低的树合并，那么就会发生退化，近似变成一个链表，为了避免这种情况，采取一些优化操作进行路径压缩。 对于每棵树，记录这棵树的高度 合并时，高度小的树向高度大的树连边 在查询过程中向上经过的所有节点，都改为直接连到根节点 实例讲解食物链（POJ No.1182）Description 动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B，B吃C，C吃A。现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。有人用两种说法对这N个动物所构成的食物链关系进行描述：第一种说法是”1 X Y”，表示X和Y是同类。第二种说法是”2 X Y”，表示X吃Y。此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。1） 当前的话与前面的某些真的话冲突，就是假话；2） 当前的话中X或Y比N大，就是假话；3） 当前的话表示X吃X，就是假话。你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。 Input 第一行是两个整数N和K，以一个空格分隔。以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。若D=1，则表示X和Y是同类。若D=2，则表示X吃Y。 Output 只有一个整数，表示假话的数目。 这道题是一道经典的并查集题目，该题难点在于元素之间的关系有两种：同类和捕食。不能想当然地按照A、B、C三种动物来分类，因为并查集中只要有联系就会被分为一组，如何巧妙地维护这两种关系是解决问题的关键。 思路一：改变元素一个动物只有三种情况：A、B、C，既然根据所给信息无法确定某一动物到底属于哪一种动物，那么不妨将这三种情况均记录下来，即对于每只动物i创建三个元素i-A，i-B，i-C，并用这3*N个元素建立并查集，并查集里的每一个组都代表组内所有元素代表的情况都同时发生或不发生，若x和y属于同一种类，合并x-A和y-A、x-B和y-B、x-C和y-C;若x吃y，则合并x-A和y-B、x-B和y-C、x-C和y-A。在合并之前先判断是否会产生矛盾即可判断当前信息是否正确。 实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;using namespace std;#define MAX_N 5000*3#define MAX_K 100000int N, K;int T[MAX_K], X[MAX_K], Y[MAX_K];int par[MAX_N];int rank[MAX_N];void init(int n)&#123; for (int i = 0; i &lt; n; i++) &#123; par[i] = i; rank[i] = 0; &#125;&#125;int find(int x)&#123; if (par[x] == x) return x; return par[x] = find(par[x]);&#125;void unite(int x, int y)&#123; x = find(x); y = find(y); if (x == y) return; if (rank[x] &lt; rank[y]) &#123; par[x] = y; &#125; else &#123; par[y] = x; if (rank[x] == rank[y]) rank[x]++; &#125;&#125;bool same(int x, int y)&#123; return find(x) == find(y);&#125;int main()&#123; scanf("%d %d", &amp;N, &amp;K); for (int i = 0; i &lt; K; i++) &#123; scanf("%d %d %d", &amp;T[i], &amp;X[i], &amp;Y[i]); &#125; init(N * 3); int ans = 0; for (int i = 0; i &lt; K; i++) &#123; int t = T[i]; int x = X[i] - 1, y = Y[i] - 1; if (x &lt; 0 || N &lt;= x || y &lt; 0 || N &lt;= y) &#123; ans++; continue; &#125; if (t == 1) &#123; if (same(x, y + N) || same(x, y + 2 * N)) ans++; else &#123; unite(x, y); unite(x + N, y + N); unite(x + 2 * N, y + 2 * N); &#125; &#125; else &#123; if (same(x, y) || same(x, y + 2 * N)) ans++; else &#123; unite(x, y + N); unite(x + N, y + 2 * N); unite(x + 2 * N, y); &#125; &#125; &#125; printf("%d\n", ans);&#125; 思路二：带权并查集维护的两种关系可以用节点上所带的权值来表示，我们可以把这2个元素之间的关系量转化为一个偏移量，用一个relation[N]数组来记录每个节点到其根节点的偏移量: x-&gt;y 偏移量0时 x和y同类 x-&gt;y 偏移量1时 x被y吃 x-&gt;y 偏移量2时 x吃y 只需要在查询和合并节点时，更新节点到根节点的偏移量即可。只要注意，更新偏移量类似向量加减法，具有方向性。 实现代码略。]]></content>
      <categories>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS & BFS]]></title>
    <url>%2F2019%2F05%2F17%2FDFS-BFS%2F</url>
    <content type="text"><![CDATA[本文主要介绍了穷竭搜索的两个算法DFS和BFS及它们的实现代码。 原理简介深度优先搜索（DFS）是从某个状态开始，不断地转移到下一个状态，直到“底部”，然后回退到上一个状态，继续搜索该状态可转移的其他状态，不断重复以上过程，得到最终解。一般采用递归函数实现。 宽度优先搜索（BFS）是先搜索离当前状态最近的状态，再搜索次近一点的状态……深度优先搜索类似利用栈计算的方式，将栈顶能转移的状态入栈，直到无可转移状态后再出栈；宽度优先搜索则类似利用队列计算的方式，将当前状态可转移的最近的状态依次加入队列，再从队列前端取出状态，然后将该状态可以转移但未访问过的状态加入队列……其代码实现也正是利用了C++中的queue。 实例讲解Lake Counting（POJ No.2386）Description Due to recent rains, water has pooled in various places in Farmer John’s field, which is represented by a rectangle of N x M (1 &lt;= N &lt;= 100; 1 &lt;= M &lt;= 100) squares. Each square contains either water (‘W’) or dry land (‘.’). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors. Input Line 1: Two space-separated integers: N and M Lines 2..N+1: M characters per line representing one row of Farmer John’s field. Each character is either ‘W’ or ‘.’. The characters do not have spaces between them. Output Line 1: The number of ponds in Farmer John’s field. 只要从任意W开始，用.代替，穷竭搜索其邻接的W，并用.代替，直到图中不存在W为止，此时调用DFS搜索的次数就是答案。 实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;using namespace std;#define MAX_N 100#define MAX_M 100int N, M;char field[MAX_N + 1][MAX_M + 1];void dfs(int x, int y)&#123; field[x][y] = '.'; for (int dx = -1; dx &lt;= 1; dx++) &#123; for (int dy = -1; dy &lt;= 1; dy++) &#123; int nx = x + dx, ny = y + dy; if (0 &lt;= nx &amp;&amp; nx &lt; N &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; M &amp;&amp; field[nx][ny] == 'W') dfs(nx, ny); &#125; &#125;&#125;int main()&#123; int res = 0; scanf("%d %d", &amp;N, &amp;M); for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; M; j++) &#123; scanf("%c", &amp;field[i][j]); &#125; getchar(); &#125; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; M; j++) &#123; if (field[i][j] == 'W') &#123; dfs(i, j); res++; &#125; &#125; &#125; printf("%d\n",res);&#125; 迷宫的最短路径给定一个大小为N*M的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四格的通道移动。请求出从起点到终点所需的最小步数。 题目要求最短路径，很容易想到用BFS，因为它最先搜索距离最近的点，我们只需要从起点开始搜索，用一个d[N][M]数组把各点到起点的距离保存起来，就能求出起点到终点的最短距离。 实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;utility&gt;#include &lt;algorithm&gt;using namespace std;#define MAX_N 100#define MAX_M 100const int INF = 100000000;typedef pair&lt;int, int&gt; P;int dx[4] = &#123;1, 0, -1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;; //4个方向移动的向量char maze[MAX_N + 1][MAX_M + 1];int N, M;int sx, sy;int gx, gy;int d[MAX_N + 1][MAX_M + 1];int bfs()&#123; queue&lt;P&gt; que; for (int i = 0; i &lt; N; i++) fill(d[i], d[i] + M, INF); que.push(P(sx, sy)); d[sx][sy] = 0; while (que.size()) &#123; P p = que.front(); que.pop(); if (p.first == gx &amp;&amp; p.second == gy) break; for (int i = 0; i &lt; 4; i++) &#123; int nx = p.first + dx[i], ny = p.second + dy[i]; if (0 &lt;= nx &amp;&amp; nx &lt; N &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; M &amp;&amp; maze[nx][ny] != '#' &amp;&amp; d[nx][ny] == INF) &#123; que.push(P(nx, ny)); d[nx][ny] = d[p.first][p.second] + 1; &#125; &#125; &#125; return d[gx][gy];&#125;int main()&#123; scanf("%d %d", &amp;N, &amp;M); for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; M; j++) &#123; scanf("%c", &amp;maze[i][j]); if (maze[i][j] == 'S') &#123; sx = i; sy = j; &#125; if (maze[i][j] == 'G') &#123; gx = i; gy = j; &#125; &#125; getchar(); &#125; int res = bfs(); printf("%d\n",res);&#125;]]></content>
      <categories>
        <category>DFS&amp;BFS</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2019%2F05%2F16%2FDP%2F</url>
    <content type="text"><![CDATA[简单来说，动态规划即记忆化搜索。本文简单介绍了动态规划的原理及代码实现。 原理简介对于某些问题，进行穷竭搜索并不是最优解，某些节点会被多次计算，这导致时间、空间复杂度的增加。动态规划就是用来将这些结果记录下来，能大大降低复杂度的算法。要用动态规划解决问题必须先对问题的状态进行合理的假设，建立状态转移方程，确定边界。 一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！ 每个阶段只有一个状态-&gt;递推； 每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心； 每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索； 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。 实例讲解01背包问题有n个重量和价值分别为wi，vi的物品。从这些物品中挑选出总重量不超过W的物品，求所有挑选方案中价值总和的最大值。 这里，我们可以定义： $$ dp[i+1][j]：从0到i这i+1个物品中选出重量不超过j的物品时总价值的最大值 $$ 因此，两个状态的转移就有两种可能：选第i个物品；不选第i个物品。得到状态转移方程： $$dp[i+1][j] =\begin{cases}dp[i][j] &amp; (j&lt;w[i]) \\max(dp[i][j],dp[i][j-w[i]]+v[i]) &amp; (其他)\end{cases}$$ 实现代码如下： 12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define MAX_N 100#define MAX_W 10000int dp[MAX_N + 1][MAX_W + 1];int main()&#123; int n, W; int w[MAX_N + 1], v[MAX_N + 1]; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf("%d %d", &amp;w[i], &amp;v[i]); &#125; scanf("%d", &amp;W); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= W; j++) &#123; if (j &lt; w[i]) dp[i + 1][j] = dp[i][j]; else dp[i + 1][j] = max(dp[i][j], dp[i][j - w[i]] + v[i]); &#125; &#125; printf("%d\n", dp[n][W]);&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
