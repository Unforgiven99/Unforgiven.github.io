<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[状态压缩DP、矩阵快速幂以及线段树优化DP]]></title>
    <url>%2F2019%2F06%2F17%2FState-Compression-DP%26Fast-Power-Of-Matrix%26Segment-Tree-Optimization-DP%2F</url>
    <content type="text"><![CDATA[本文主要是对动态规划更深入的介绍，包括状态压缩、优化等，以及矩阵快速幂的讲解。 原理简介之前介绍的动态规划都是基于整数的，在某些情况下，需要我们针对集合等进行动态规划，实现原理是把它编码成一个整数，或者给它们定义一个全序关系并用二叉搜索树储存，从而求解。特别的对于集合我们可以把每一个元素的选取与否对应到一个二进制位里，从而把状态压缩成一个整数。 快速幂运算是用来加速幂运算的方法，可使复杂度降到O(logn)，假设n为指数，将n表示为2的幂次的和。 $$ n=x^{k_{1}}+x^{k_{2}}+x^{k_{3}}… $$ 那么有 $$ x^{n}=x^{2^{k_{1}}}x^{2^{k_{2}}}x^{2^{k_{3}}}… $$ 只要在依次求$x^{2^{i}}$的同时进行计算就好了。 有些情况下，使用数据结构优化动态规划，可以使动态规划更高效，比如动态规划中有时会查询区间的最值来更新dp数组，此时可以用线段树或者树状数组来进行优化。 实例讲解旅行商问题给定一个n个顶点组成的带权有向图的距离矩阵d(I,j)（INF表示没有边）。要求从顶点0出发，经过每个顶点恰好一次后再回到顶点0。问所经过的边的总权重的最小值是多少？ 尝试每一种情况是不现实的，我们可以采用DP来解决，假设现在已经访问过的点的集合（起点0当作还未访问过的点）为S，当前所在的顶点为v，dp[S][v]表示从v出发访问剩余的所有顶点，最终回到顶点0的路径的权重总和的最小值，可以得到递推式如下： $$ dp[V][0]=0 $$$$ dp[S][v]=min\begin{Bmatrix}dp[S\cup {u}][u]+d(v,u)|u\notin S\end{Bmatrix} $$ 然后将S二进制编码成整数即可。 伪代码如下： 1234567891011121314151617int n;int d[MAX_N][MAX_N];int dp[1 &lt;&lt; MAX_N][MAX_N];void solve()&#123; for (int S = 0; S &lt; 1 &lt;&lt; n; S++) fill(dp[S], dp[S] + n, INF); dp[(1 &lt;&lt; n) - 1][0] = 0; for (int S = (1 &lt;&lt; n) - 2; S &gt;= 0; S--) &#123; for (int v = 0; v &lt; n; v++) &#123; for (int u = 0; u &lt; n; u++) &#123; if (!(S &gt;&gt; u &amp; 1)) dp[S][v] = min(dp[S][v], dp[S | 1 &gt;&gt; u][u] + d[v][u]); &#125; &#125; &#125; printf("%d\n", dp[0][0]);&#125; 斐波那契数列斐波那契数列是由如下递推式定义的数列 $$ F_{0}=0 $$$$ F_{1}=1 $$$$ F_{n+2}=F_{n+1}+F_{n} $$ 求这个数列第n项的值对$10_{4}$取余后的结果。 如果直接用递推式求复杂度过高，可以发现递推式可以表示成矩阵 $$\begin{bmatrix}F_{n+2}\\F_{n+1}\end{bmatrix}=\begin{bmatrix}1 &amp; 1\\1 &amp; 0\end{bmatrix}\begin{bmatrix}F_{n+1}\\F_{n}\end{bmatrix}$$ 记该矩阵为A，则有 $$\begin{bmatrix}F_{n+1}\\F_{n+0}\end{bmatrix}=A^{n}\begin{bmatrix}F_{1}\\F_{0}\end{bmatrix}=A^{n}\begin{bmatrix}1\\0\end{bmatrix}$$ 再使用矩阵快速幂运算即可可降低复杂度。 伪代码如下 12345678910111213141516171819202122232425262728293031323334353637383940typedef vector&lt;int&gt; vec;typedef vector&lt;vec&gt; mat;typedef long long ll;const int M = 10000;ll n;mat mul(mat &amp;A, mat &amp;B)&#123; mat C(A.size(), vec(B[0].size())); for (int i = 0; i &lt; A.size(); i++) &#123; for (int j = 0; j &lt; B[0].size(); j++) &#123; for (int k = 0; k &lt; B.size(); k++) &#123; C[i][j] = C[i][j] + A[i][k] * B[k][j] % M; &#125; &#125; &#125; return C;&#125;mat pow(mat A, ll n)&#123; mat B(A.size(), vec(A.size())); for (int i = 0; i &lt; A.size(); i++) B[i][i] = 1; while(n &gt; 0) &#123; if (n &amp; 1) B = mul(B, A); A = mul(A, A); n &gt;&gt;= 1; &#125; return B;&#125;void solve()&#123; mat A(2, vec(2)); A[0][0] = 1; A[0][1] = 1; A[1][0] = 1; A[1][1] = 0; A = pow(A, n); printf("%d\n", A[1][0]);&#125; Minimizing maximizer（POJ 1769）Description The company Chris Ltd. is preparing a new sorting hardware called Maximizer. Maximizer has n inputs numbered from 1 to n. Each input represents one integer. Maximizer has one output which represents the maximum value present on Maximizer’s inputs. Maximizer is implemented as a pipeline of sorters Sorter(i1, j1), … , Sorter(ik, jk). Each sorter has n inputs and n outputs. Sorter(i, j) sorts values on inputs i, i+1,… , j in non-decreasing order and lets the other inputs pass through unchanged. The n-th output of the last sorter is the output of the Maximizer. An intern (a former ACM contestant) observed that some sorters could be excluded from the pipeline and Maximizer would still produce the correct result. What is the length of the shortest subsequence of the given sequence of sorters in the pipeline still producing correct results for all possible combinations of input values? Task Write a program that: reads a description of a Maximizer, i.e. the initial sequence of sorters in the pipeline,computes the length of the shortest subsequence of the initial sequence of sorters still producing correct results for all possible input data,writes the result. Input The first line of the input contains two integers n and m (2 &lt;= n &lt;= 50000, 1 &lt;= m &lt;= 500000) separated by a single space. Integer n is the number of inputs and integer m is the number of sorters in the pipeline. The initial sequence of sorters is described in the next m lines. The k-th of these lines contains the parameters of the k-th sorter: two integers ik and jk (1 &lt;= ik &lt; jk &lt;= n) separated by a single space. Output The output consists of only one line containing an integer equal to the length of the shortest subsequence of the initial sequence of sorters still producing correct results for all possible data. 可以知道，最大值如果在一个sorter的区间中，那么该sorter输出中最大值会被移动到第jk个位置上，只要对于最大值出现在第一个位置的情况，最后可以被移动到最后一个位置，那么该最短子序列就是可以工作的。考虑用DP解决，假设dp[i][j]为到第i个sorter为止，最大值被移动到第i个位置所需要的最短的子序列的长度，那么 $$ dp[0][1]=0 $$$$ dp[0][j]=INF(j&gt;1) $$$$dp[i]j$$ 由于$j_{k}\neq j$时，dp[i+1][j]=dp[i][j]，所以我们可以只使用同一个一维数组更新,假设dp[j]表示最大值被移动到第i个位置所需要的最短的子序列的长度 $$ dp[1]=0,dp[j]=INF(j&gt;1) $$$$ dp[j_{k}]=min(dp[j_{k}],min(dp[j^{‘}]|i_{k}\leq j^{‘}\leq j_{k})+1) $$ 更新时使用线段树来维护即可达到要求的复杂度。 实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;#define MAX_N 100000#define MAX_M 500000#define INF (1 &lt;&lt; 16) - 1int N;int n, m;int s[MAX_M], t[MAX_M];int dp[MAX_N + 1];int dat[2 * MAX_N - 1];void init(int _n)&#123; N = 1; while (N &lt; _n) N *= 2; for (int i = 0; i &lt; 2 * N - 1; i++) dat[i] = INF; &#125;void update(int k, int a)&#123; k += N - 1; dat[k] = a; while (k &gt; 0) &#123; k = (k - 1) / 2; dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]); &#125;&#125;int query(int a, int b, int k, int l, int r)&#123; if (r &lt;= a || b &lt;= l) return INF; if (a &lt;= l &amp;&amp; r &lt;= b) return dat[k]; else &#123; int vl = query(a, b, 2 * k + 1, l, (l + r) / 2); int vr = query(a, b, 2 * k + 2, (l + r) / 2, r); return min(vl, vr); &#125;&#125;int main()&#123; scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) scanf("%d %d",&amp;s[i], &amp;t[i]); init(n); fill(dp, dp + n + 1, INF); dp[1] = 0; update(0, 0); for (int i = 0; i &lt; m; i++) &#123; int v = min(dp[t[i]], query(s[i] - 1, t[i], 0, 0, N) + 1); dp[t[i]] = v; update(t[i] - 1, v); &#125; printf("%d\n", dp[n]);&#125;]]></content>
      <categories>
        <category>状态压缩DP、矩阵快速幂以及线段树优化DP</category>
      </categories>
      <tags>
        <tag>状态压缩DP</tag>
        <tag>矩阵快速幂</tag>
        <tag>线段树优化DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分桶法和平方分割]]></title>
    <url>%2F2019%2F05%2F24%2FBucket-Method%26Sqrt-Decomposition%2F</url>
    <content type="text"><![CDATA[本文主要讲解了分桶法和平方分割的基本原理，同时基于一题简单讲解了归并树、划分树、主席树。 原理简介分桶法是把一排物品或平面分成桶，每个桶分别维护自己内部的信息，以达到高效计算的目的的方法。 平方分割是把排成一排的n个元素每$\sqrt{x}$个分在一个桶内进行维护的方法的统称。以下以RMQ为例讲解平方分割的实现。 预处理令$b=floor(\sqrt{x})$，把a中的元素每b个分成一个桶，并且计算出每个桶内的最小值。 查询 如果桶完全包含在区间内，则查询桶的最小值。 如果元素所在的桶不完全被区间包含，则逐个检查比较得到最小值。 更新遍历一遍桶内的元素即可。 实例讲解K-th Number（POJ 2104）Description You are working for Macrohard company in data structures department. After failing your previous task about key insertion you were asked to write a new data structure that would be able to return quickly k-th order statistics in the array segment.That is, given an array a[1…n] of different integer numbers, your program must answer a series of questions Q(i, j, k) in the form: “What would be the k-th number in a[i…j] segment, if this segment was sorted?”For example, consider the array a = (1, 5, 2, 6, 3, 7, 4). Let the question be Q(2, 5, 3). The segment a[2…5] is (5, 2, 6, 3). If we sort this segment, we get (2, 3, 5, 6), the third number is 5, and therefore the answer to the question is 5. Input The first line of the input file contains n — the size of the array, and m — the number of questions to answer (1 &lt;= n &lt;= 100 000, 1 &lt;= m &lt;= 5 000).The second line contains n different integer numbers not exceeding 109 by their absolute values — the array for which the answers should be given.The following m lines contain question descriptions, each description consists of three numbers: i, j, and k (1 &lt;= i &lt;= j &lt;= n, 1 &lt;= k &lt;= j - i + 1) and represents the question Q(i, j, k). Output For each question output the answer to it — the k-th number in sorted a[i…j] segment. 这道题有很多种解法。 思路一：平方分割题目要求区间内第k大的数，但对每个区间排序再求复杂度太高，考虑到第k大的数意味着对于这个数来说，区间内有k个小于等于它的数，所以我们可以对整个数列使用二分搜索不超过x的数的个数，每次查询可以使用平方分割来优化，分割后将桶内元素排序存入即可。 对于完全包含在区间内的桶，用二分搜索计算个数。 对于所在的桶不完全包含在区间内的元素，逐个检查。 注意：这里的二分搜索应使得结果应为符合要求的数中最大的那个，这样才能保证二分出的数是区间内的数。 实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;#define MAX_N 100000#define MAX_M 5000typedef long long ll;const int B = 1000;int N, M;int A[MAX_N];int I[MAX_M], J[MAX_M], K[MAX_M];int nums[MAX_N];vector&lt;int&gt; bucket[MAX_N / B];int main()&#123; scanf("%d %d", &amp;N, &amp;M); for (int i = 0; i &lt; N; i++) scanf("%d", &amp;A[i]); for (int i = 0; i &lt; M; i++) scanf("%d %d %d", &amp;I[i], &amp;J[i], &amp;K[i]); for (int i = 0; i &lt; N; i++) &#123; bucket[i / B ].push_back(A[i]); nums[i] = A[i]; &#125; sort(nums, nums + N); for (int i = 0; i &lt; N / B; i++) sort(bucket[i].begin(), bucket[i].end()); for (int i = 0; i &lt; M; i++) &#123; int l = I[i] - 1, r = J[i], k = K[i]; int lb = -1, ub = N - 1; while (ub - lb &gt; 1) &#123; int md = (lb + ub) / 2; int x = nums[md]; int tl = l, tr = r, c = 0; while (tl &lt; tr &amp;&amp; tl % B != 0) if (A[tl++] &lt;= x) c++; while (tl &lt; tr &amp;&amp; tr % B != 0) if (A[--tr] &lt;= x) c++; while (tl &lt; tr) &#123; int b = tl / B; c += upper_bound(bucket[b].begin(), bucket[b].end(), x) - bucket[b].begin(); tl += B; &#125; if (c &gt;= k) ub = md; else lb = md; &#125; printf("%d\n", nums[ub]); &#125;&#125; 思路二：归并树（区域树）归并树实际上就是线段树，只不过这个线段树的节点不是某个值，而是一个数组，而且是有序数组。归并树也叫区域树，节点除了是数组外还可以是线段树。因为在建树的时候它是从叶子节点开始把一个一个较小的（有序）数组归并到父节点上，是一个标准的归并排序的操作。所以被叫做归并树。 和上个思路差不多，只是查询是使用线段树来维护的，每个节点保存对应区间排好序的结果，于是变成归并树。 实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;#define MAX_N 100000#define MAX_M 5000typedef long long ll;const int ST_SIZE = (1 &lt;&lt; 18) - 1;int N, M;int A[MAX_N];int I[MAX_M], J[MAX_M], K[MAX_M];int nums[MAX_N];vector&lt;int&gt; dat[ST_SIZE];void init(int k, int l, int r)&#123; if (r - 1 == l) dat[k].push_back(A[l]); else &#123; int lch = k * 2 + 1, rch = k * 2 + 2; init(lch, l, (l + r) / 2); init(rch, (l + r) / 2, r); dat[k].resize(r - l); merge(dat[lch].begin(), dat[lch].end(), dat[rch].begin(), dat[rch].end(), dat[k].begin()); &#125;&#125;int query(int i, int j, int x, int k, int l, int r)&#123; if (j &lt;= l || r &lt;= i) return 0; else if (i &lt;= l &amp;&amp; r &lt;= j) return upper_bound(dat[k].begin(), dat[k].end(), x) - dat[k].begin(); else &#123; int lc = query(i, j, x, k * 2 + 1, l, (l + r) / 2); int rc = query(i, j, x, k * 2 + 2, (l + r) / 2, r); return lc + rc; &#125;&#125;int main()&#123; scanf("%d %d", &amp;N, &amp;M); for (int i = 0; i &lt; N; i++) scanf("%d", &amp;A[i]); for (int i = 0; i &lt; M; i++) scanf("%d %d %d", &amp;I[i], &amp;J[i], &amp;K[i]); for (int i = 0; i &lt; N; i++) nums[i] = A[i]; sort(nums, nums + N); init(0, 0, N); for (int i = 0; i &lt; M; i++) &#123; int l = I[i] - 1, r = J[i], k = K[i]; int lb = -1, ub = N - 1; while (ub - lb &gt; 1) &#123; int md = (lb + ub) / 2; int c = query(l, r, nums[md], 0, 0, N); if (c &gt;= k) ub = md; else lb = md; &#125; printf("%d\n", nums[ub]); &#125; system("pause");&#125; 思路三：主席树主席树是一种维护区间前缀信息的数据结构。主席树定义每个节点的值为其对应的区间中，当前前缀中所有的数出现的次数，需要先把全部数据离散化，每个前缀建立一棵线段树，但不是普通的线段树，而是化简后的，因为相邻前缀的线段树只有一条路径的差别，所以新建的线段树只需要保存更新的节点，其他节点只需要连接旧线段树上相应节点即可（相当于共享儿子节点）。 初始化需要先建一棵空的线段树,每个节点值均为0。 更新只需要重新开log(n)个结点来存放被更新的结点值，其他结点可以与旧的线段树共用。如图所示： 查询要查询某个前缀中不大于x的数的个数，只要找到代表该前缀的根，搜索该线段树即可。而要查询区间，则需要两个前缀相应节点值相减，代表待查询区间的数在各相应区间出现的次数。 实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;#define MAX_N 100000#define MAX_M 5000typedef long long ll;struct tree &#123; int l, r, sum;&#125;;int N, M;int A[MAX_N];int I[MAX_M], J[MAX_M], K[MAX_M];int root[MAX_N];tree ts[MAX_N * 20];vector&lt;int&gt; v;int tot = 0;int getid(int k)&#123; return lower_bound(v.begin(), v.end(), k) - v.begin();&#125;void init(int &amp;k, int l, int r)&#123; k = ++tot; ts[k].sum = 0; if (r - 1 == l) return; else &#123; int mid = (l + r) / 2; init(ts[k].l, l, mid); init(ts[k].r, mid, r); &#125;&#125;void update(int l, int r, int &amp;now, int last, int x)&#123; now = ++tot; ts[now] = ts[last]; ts[now].sum++; if (r - 1 == l) return; else &#123; int mid = (l + r) / 2; if (x &lt; mid) update(l, mid, ts[now].l, ts[last].l, x); else update(mid, r, ts[now].r, ts[last].r, x); &#125;&#125;int query(int l, int r, int x, int y, int k)&#123; if (r - 1 == l) return l; else &#123; int mid = (l + r) / 2; int cnt = ts[ts[y].l].sum - ts[ts[x].l].sum; if (cnt &gt;= k) return query(l, mid, ts[x].l, ts[y].l, k); else return query(mid, r, ts[x].r, ts[y].r, k - cnt); &#125;&#125;int main()&#123; scanf("%d %d", &amp;N, &amp;M); for (int i = 0; i &lt; N; i++) &#123; scanf("%d", &amp;A[i]); v.push_back(A[i]); &#125; sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); init(root[0], 0, N); for (int i = 0; i &lt; N; i++) update(0, N, root[i + 1], root[i], getid(A[i])); for (int i = 0; i &lt; M; i++) &#123; scanf("%d %d %d", &amp;I[i], &amp;J[i], &amp;K[i]); printf("%d\n", v[query(0, N, root[I[i] - 1], root[J[i]], K[i])]); &#125;&#125; 思路四：划分树划分树是一个类似快排操作的数据结构。给定一序列a[1…n]，sorted[1…n]为序列从小到大的排列结果。对于划分树的每一个节点(叶子节点除外)，其保存的区间[left, right]中小于等于sorted[(left+right)/2]的进入该结点的左子树，否则进入该节点的右子树。为了方便查询，我们增加一个数组cnt[i]用来记录第i个元素及之前的元素进入左孩子的个数。这样，要查询区间中第k小的数，只需要知道区间中多少个数进入左孩子，并和k比较，就可以更新查询节点和区间以及k，从而递归查询出结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;#define MAX_N 100000#define MAX_M 5000#define MAX_D 20typedef long long ll;struct tree &#123; int num[MAX_N]; int cnt[MAX_N];&#125;;int N, M;int A[MAX_N];int I[MAX_M], J[MAX_M], K[MAX_M];tree ts[MAX_D];int sorted[MAX_N];void init(int dep, int l, int r)&#123; if (r - 1 == l) return; else &#123; int mid = (l + r) / 2; int same = mid -l; for (int i = l; i &lt; r; i++) if (ts[dep].num[i] &lt; sorted[mid]) same--; int lt = l, rt = mid; for (int i = l; i &lt; r; i++) &#123; if (i == l) ts[dep].cnt[i] = 0; else ts[dep].cnt[i] = ts[dep].cnt[i - 1]; int num = ts[dep].num[i]; if (num &lt; sorted[mid] || num == sorted[mid] &amp;&amp; same) &#123; if (num == sorted[mid]) same--; ts[dep].cnt[i]++; ts[dep + 1 ].num[lt++] = num; &#125; else ts[dep + 1 ].num[rt++] = num; &#125; init(dep + 1, l, mid); init(dep + 1, mid, r); &#125;&#125;int query(int dep, int l, int r, int x, int y, int k)&#123; if (r - 1 == l) return ts[dep].num[l]; else &#123; int mid = (l + r) / 2; int sum = ts[dep].cnt[y - 1]; int res = 0; if (l != x) &#123; res = ts[dep].cnt[x - 1]; sum -= res; &#125; if (sum &gt;= k) &#123; x = l + res; y = x + sum; return query(dep + 1, l, mid, x, y, k); &#125; else &#123; int rx = x - l - res; int ry = y - x - sum; x = mid + rx; y = x + ry; return query(dep + 1, mid, r, x, y, k - sum); &#125; &#125;&#125;int main()&#123; scanf("%d %d", &amp;N, &amp;M); for (int i = 0; i &lt; N; i++) &#123; scanf("%d", &amp;A[i]); ts[0].num[i] = A[i]; sorted[i] = A[i]; &#125; sort(sorted, sorted + N); init(0, 0, N); for (int i = 0; i &lt; M; i++) &#123; scanf("%d %d %d", &amp;I[i], &amp;J[i], &amp;K[i]); printf("%d\n",query(0, 0, N, I[i] - 1, J[i], K[i])); &#125;&#125;]]></content>
      <categories>
        <category>分桶法和平方分割</category>
      </categories>
      <tags>
        <tag>分桶法</tag>
        <tag>平方分割</tag>
        <tag>归并树</tag>
        <tag>划分树</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组]]></title>
    <url>%2F2019%2F05%2F23%2FBinary-Indexed-Tree%2F</url>
    <content type="text"><![CDATA[本文主要介绍了树状数组的基本原理和与线段树的区别。 原理简介树状数组是能完成以下操作的数据结构： 给定一个初始值全为0的数列a1，a2，…，an 给定i，计算a1+a2+…+ai 给定i和x，更新ai+=x 树状数组可以看作是线段树的简化版本，其将线段树所有右儿子略去，降低了复杂度，而且这样还可以使每个节点对应的区间长度和节点编号的二进制表示对应起来：以1结尾的编号为1，3，5，7的节点区间长度是1，最后只有1个0的2，6的区间长度是2，最后有两个0的4的区间长度是4……利用这个性质，可以用位运算实现树状数组的操作。 求和计算前i项的和需要从i开始，不断将当前i对应的值加入到结果中，并从i中减去i的二进制最低非0位对应的幂，直到i为0。i的二进制最低非0位对应的幂可以通过i&amp;-i得到。 更新使第i项的值增加x需要从i开始，不断将当前i对应的值增加x，并把i的二进制最低非0位对应的幂加到i上。 代码实现12345678910111213141516171819int bit[MAX_N + 1], n;int sum(int i)&#123; int s = 0; while(i) &#123; s += bit[i]; i -= i &amp; -i; &#125; return s;&#125;void add(int i, int x)&#123; while(i &lt;= n) &#123; bit[i] += x; i += i &amp; -i; &#125;&#125; 实例讲解冒泡排序的交换次数给定一个1~n的排列a0，a1，…，an-1，求对这个数列进行冒泡排序所需要的交换次数。 这是一道求逆序对（满足i&lt;j，ai&gt;aj的(i，j)数对）个数的问题，是一个典型的树状数组的入门题。我们可以遍历一次数列，当出现一个数时，树状数组中该编号对应值加1，标记该数已经出现过一次，这样的话，计算树状数组中该编号之前的项的和就可以得到该数之前与该数构成的顺序对的个数，用遍历的序号减去该个数即得到逆序对个数。 实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;#define MAX_N 100000typedef long long ll;int bit[MAX_N + 1];int n, a[MAX_N];int sum(int i)&#123; int s = 0; while(i) &#123; s += bit[i]; i -= i &amp; -i; &#125; return s;&#125;void add(int i, int x)&#123; while(i &lt;= n) &#123; bit[i] += x; i += i &amp; -i; &#125;&#125;int main()&#123; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]); ll ans = 0; for (int j = 0; j &lt; n; j++) &#123; ans += j - sum(a[j]); add(a[j], 1); &#125; printf("%d\n", ans);&#125; A Simple Problem with Integers（POJ 3468）Description You have N integers, A1, A2, … , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval. Input The first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000.The second line contains N numbers, the initial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000.Each of the next Q lines represents an operation.“C a b c” means adding c to each of Aa, Aa+1, … , Ab. -10000 ≤ c ≤ 10000.“Q a b” means querying the sum of Aa, Aa+1, … , Ab. Output You need to answer all Q commands in order. One answer in a line. 经典的区间更新求和模板。 看似区间更新，无法使用树状数组，其实不然。这里先介绍用线段树的方法，再介绍树状数组方法。 思路一：线段树区间更新对区间求和的影响无非两种：更新的区间包含在求和区间内；更新的区间和求和区间有交集。那不妨让线段树维护这两种情况的数据： 该节点对应的区间内所有元素应共同加的值 该节点对应的区间内仅部分元素需要加的值 那么，按照线段树的操作将查询区间二进制划分，即可在O(log n)时间内完成求和。 实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;#define MAX_N 100000#define MAX_Q 100000typedef long long ll;const int DAT_SIZE = (1 &lt;&lt; 18) - 1;int N, Q;int A[MAX_N];char T[MAX_Q];int L[MAX_Q], R[MAX_Q], X[MAX_Q];ll data[DAT_SIZE], datb[DAT_SIZE];void add(int a, int b, int x, int k, int l, int r)&#123; if (a &lt;= l &amp;&amp; r &lt;= b) data[k] += x; else if (l &lt; b &amp;&amp; a &lt; r) &#123; datb[k] += (min(b, r) - max(a, l)) * x; add(a, b, x, 2 * k + 1, l, (l + r) / 2); add(a, b, x, 2 * k + 2, (l + r) / 2, r); &#125;&#125;ll sum(int a, int b, int k, int l, int r)&#123; if (b &lt;= l | r &lt;= a) return 0; else if (a &lt;= l &amp;&amp; r &lt;= b) return data[k] * (r - l) + datb[k]; else &#123; ll res = (min(b, r) - max(a, l)) * data[k]; res += sum(a, b, 2 * k + 1, l, (l + r) / 2); res += sum(a, b, 2 * k + 2, (l + r) / 2, r); return res; &#125;&#125;int main()&#123; scanf("%d %d", &amp;N, &amp;Q); for (int i = 0; i &lt; N; i++) scanf("%d", &amp;A[i]); for (int i = 0; i &lt; Q; i++) &#123; getchar(); scanf("%c", &amp;T[i]); if (T[i] == 'C') scanf("%d %d %d", &amp;L[i], &amp;R[i], &amp;X[i]); else scanf("%d %d", &amp;L[i], &amp;R[i]); &#125; for (int i = 0; i &lt; N; i++) add(i, i + 1, A[i], 0, 0, N); for (int i = 0; i &lt; Q; i++) &#123; if (T[i] == 'C') add(L[i] - 1, R[i], X[i], 0, 0, N); else printf("%lld\n", sum(L[i] - 1, R[i], 0, 0, N)); &#125;&#125; 思路二：树状数组同样，讨论两种情况对前缀和的影响，令 $$ s(i)=加上x之前的\sum_{j=1}^{i}a_{j} $$$$ s^{‘}(i)=加上x之前的\sum_{j=1}^{i}a_{j} $$ 有 $$ l\leq i\leq r\rightarrow s^{‘}(i)=s(i)+x\times (i-l+1)=s(i)+x\times i-x\times (l-1) $$$$ r&lt; l\rightarrow s^{‘}(i)=s(i)+x\times (r-l+1) $$ 所以，我们可以用两个树状数组来维护，令 $$ \sum_{j=1}^{i}a_{j}=sum(bit1,i)\times i+sum(bit0,i) $$ 这样，我们就只需要 在bit0的l位置加上-x(l-1) 在bit1的l位置加上x 在bit0的r+1位置加上xr 在bit0的位置加上-x 即可完成对[l，r]区间上的更新操作。 实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;#define MAX_N 500000#define MAX_Q 100000typedef long long ll;int N, Q;int A[MAX_N];char T[MAX_Q];int L[MAX_Q], R[MAX_Q], X[MAX_Q];ll bit0[MAX_N], bit1[MAX_N];ll sum(ll *b, int i)&#123; ll s = 0; while(i &gt; 0) &#123; s += b[i]; i -= i &amp; -i; &#125; return s;&#125;void add(ll *b, int i, int v)&#123; while(i &lt;= N) &#123; b[i] += v; i += i &amp; -i; &#125;&#125;int main()&#123; scanf("%d %d", &amp;N, &amp;Q); for (int i = 0; i &lt; N; i++) scanf("%d", &amp;A[i]); for (int i = 0; i &lt; Q; i++) &#123; getchar(); scanf("%c", &amp;T[i]); if (T[i] == 'C') scanf("%d %d %d", &amp;L[i], &amp;R[i], &amp;X[i]); else scanf("%d %d", &amp;L[i], &amp;R[i]); &#125; for (int i = 0; i &lt; N; i++) add(bit0, i + 1, A[i]); for (int i = 0; i &lt; Q; i++) &#123; if (T[i] == 'C') &#123; add(bit0, L[i], -X[i] * (L[i] - 1)); add(bit1, L[i], X[i]); add(bit0, R[i] + 1, X[i] * R[i]); add(bit1, R[i] + 1, -X[i]); &#125; else &#123; ll res = 0; res += sum(bit0, R[i]) + sum(bit1, R[i]) * R[i]; res -= sum(bit0, (L[i] - 1)) + sum(bit1, (L[i] - 1)) * (L[i] - 1); printf("%lld\n", res); &#125; &#125;&#125;]]></content>
      <categories>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树]]></title>
    <url>%2F2019%2F05%2F21%2FSegment-Tree%2F</url>
    <content type="text"><![CDATA[本文简单介绍了线段树的基本原理和其RMQ实现。 原理简介线段树是一种用来处理区间的数据结构。线段树是一棵完美二叉树（所有叶子深度都相同，并且每个节点要么是叶子，要么是有2个儿子的树），树上的每个节点都维护一个区间。根维护的是整个区间，每个节点维护的是父亲节点的区间二等分后的其中一个区间。 下面以实现了Range Minimum Query(RMQ)操作的线段树为例。 查询给定s和t，查询as，as+1，…，at的最小值。只需要从根节点递归处理： 如果所查询的区间和当前节点对应的区间没有交集，返回不影响答案的一个值。 如果所查询的区间包含了当前节点对应的区间，返回当前节点的值。 否则，对两个儿子节点递归，返回其中的最小值。 更新给定i和x，把ai的值改为x。可以从最下面的节点往上不断更新，更新为两个儿子节点的最小值即可。 代码实现123456789101112131415161718192021222324252627282930const int MAX_N = 1 &lt;&lt; 17;int n, dat[2 * MAX_N - 1];void init(int _n)&#123; n = 1; while (n &lt; _n) n *= 2; for (int i = 0; i &lt; 2 * n - 1; i++) dat[i] = INT_MAX; &#125;void update(int k, int a)&#123; k += n - 1; dat[k] = a; while (k &gt; 0) &#123; k = (k - 1) / 2; dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]); &#125;&#125;int query(int a, int b, int k, int l, int r)&#123; if (r &lt;= a || b &lt;= l) return INT_MAX; if (a &lt;= l &amp;&amp; r &lt;= b) return dat[k]; else &#123; int vl = query(a, b, 2 * k + 1, l, (l + r) / 2); int vr = query(a, b, 2 * k + 2, (l + r) / 2, r); return min(vl, vr); &#125;&#125; 实例讲解Crane（POJ 2991）Description ACM has bought a new crane (crane – jeřáb) . The crane consists of n segments of various lengths, connected by flexible joints. The end of the i-th segment is joined to the beginning of the i + 1-th one, for 1 ≤ i &lt; n. The beginning of the first segment is fixed at point with coordinates (0, 0) and its end at point with coordinates (0, w), where w is the length of the first segment. All of the segments lie always in one plane, and the joints allow arbitrary rotation in that plane. After series of unpleasant accidents, it was decided that software that controls the crane must contain a piece of code that constantly checks the position of the end of crane, and stops the crane if a collision should happen. Your task is to write a part of this software that determines the position of the end of the n-th segment after each command. The state of the crane is determined by the angles between consecutive segments. Initially, all of the angles are straight, i.e., 180o. The operator issues commands that change the angle in exactly one joint. Input The input consists of several instances, separated by single empty lines. The first line of each instance consists of two integers 1 ≤ n ≤10 000 and c 0 separated by a single space – the number of segments of the crane and the number of commands. The second line consists of n integers l1,…, ln (1 li 100) separated by single spaces. The length of the i-th segment of the crane is li. The following c lines specify the commands of the operator. Each line describing the command consists of two integers s and a (1 ≤ s &lt; n, 0 ≤ a ≤ 359) separated by a single space – the order to change the angle between the s-th and the s + 1-th segment to a degrees (the angle is measured counterclockwise from the s-th to the s + 1-th segment). Output The output for each instance consists of c lines. The i-th of the lines consists of two rational numbers x and y separated by a single space – the coordinates of the end of the n-th segment after the i-th command, rounded to two digits after the decimal point. The outputs for each two consecutive instances must be separated by a single empty line. 可以将线段转化为向量来考虑，于是求终点坐标变成了将所有线段的向量求和，当执行指令时，该线段之后的所有线段向量均需要旋转角度，这些都涉及区间操作，因此考虑使用线段树来实现。每个节点表示一段连续的线段构成的集合，并且维护两个值： 该节点包含的所有线段连接起来构成的向量坐标 该节点的右儿子在和左儿子连接之前需要旋转的角度 实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;#define MAX_N 10005#define MAX_C 10000const int ST_SIZE = (1 &lt;&lt; 15) - 1;int N, C;int L[MAX_N];int S[MAX_C], A[MAX_N];double vx[ST_SIZE], vy[ST_SIZE];double ang[ST_SIZE];double prv[MAX_N]; //保存每个节点当前角度的数组 void init(int k, int l, int r) &#123; ang[k] = vx[k] = 0.0; if (r - 1 == l) vy[k] = L[l]; else &#123; int chl = 2 * k + 1, chr = 2 * k + 2; init(chl, l , (l + r) / 2); init(chr, (l + r) / 2 , r); vy[k] = vy[chl] + vy[chr]; &#125;&#125;void change(int s, double a, int v, int l, int r)&#123; if (s &lt;= l) return; else if (s &lt; r) &#123; int chl = 2 * v + 1, chr = 2 * v + 2; int m = (l + r) / 2; change(s, a, chl, l, m); change(s, a, chr, m, r); if (s &lt;= m) ang[v] += a; double s = sin(ang[v]), c = cos(ang[v]); vx[v] = vx[chl] + (c * vx[chr] - s * vy[chr]); vy[v] = vy[chl] + (s * vx[chr] + c * vy[chr]); &#125;&#125;int main()&#123; while (scanf("%d %d", &amp;N, &amp;C) == 2) &#123; for (int i = 0; i &lt; N; i++) scanf("%d", &amp;L[i]); for (int i = 0; i &lt; C; i++) scanf("%d %d", &amp;S[i], &amp;A[i]); init(0, 0, N); fill(prv, prv + N, M_PI); for (int i = 0; i &lt; C; i++) &#123; int s = S[i]; double a = A[i] / 360.0 * 2 * M_PI; change(s, a - prv[s], 0, 0, N); prv[s] = a; printf("%.2f %.2f\n", vx[0], vy[0]); &#125; printf("\n"); &#125;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树问题]]></title>
    <url>%2F2019%2F05%2F20%2FMinimum-Spanning-Tree%2F</url>
    <content type="text"><![CDATA[本文简单介绍了最小生成树的Prim和Kruskal算法基本原理及代码实现。 原理简介给定一个无向图，如果它的某个子图中任意两个顶点都互相连通并且是一棵树，那么这棵树就叫做生成树。如果边上有权值，那么使得边权值和最小的生成树叫做最小生成树。 Prim算法Prim算法是一种从某个顶点出发，不断添加边的算法。基本原理是以任意一顶点作为开始作为树T，不断选取T和其他顶点之间相连的最小权值的边，把它加入T中，就可以得到最小生成树了。将T和顶点V相连的边的最小权值记为mincost[v]。当向T中添加顶点u时，更新mincost[v]=min(mincost[v]，边(u，v)的权值)即可。此外，采用堆维护mincost[v]可降低复杂度。 实现代码如下： 123456789101112131415161718192021222324252627int cost[MAX_V][MAX_V];int mincost[MAX_V];bool used[MAX_V];int V;int prim()&#123; for (int i = 0; i &lt; V; i++) &#123; mincost[i] = INF; used[i] = false; &#125; mincost[0] = 0; int res = 0; while(true) &#123; int v = -1; for (int u = 0; u &lt; V; u++) &#123; if (!used[u] &amp;&amp; (v == -1 || mincost[u] &lt; mincost[v]) v = u; &#125; if (v == -1) break; used[v] = true; res += mincost[v]; for (int u = 0; u &lt; V; u++) &#123; mincost[u] = min(mincost[u], cost[v][u]); &#125; &#125; return res;&#125; Kruskal算法Kruskal算法是按照边的权值从小到大遍历，若不产生圈，就把当前边加入生成树中。当把连接顶点u和v的边e加入生成树中，如果u和v不在同一个连通分量里，那么加入e不会产生圈；反之，就会产生圈。采用并查集可以高效判断两点是否属于同一个连通分量。 1234567891011121314151617181920212223242526struct edge &#123; int u, v, cost;&#125;edge es[MAX_E];int V, E;bool comp(const edge&amp; e1, const edge&amp; e2)&#123; return e1.cost &lt; e2.cost;&#125;int kruskal()&#123; sort(es, es + E, cmp); init_union_find(V); //并查集的初始化 int res = 0; for (int i = 0; i &lt; E; i++) &#123; edge e = es[i]; if (!same(e.u, e.v)) &#123; unite(e.u, e.v); res += e.cost; &#125; &#125; return res;&#125;]]></content>
      <categories>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>Prim</tag>
        <tag>Kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路问题]]></title>
    <url>%2F2019%2F05%2F19%2FShortest-Path%2F</url>
    <content type="text"><![CDATA[本文主要介绍了最短路的几个算法：Bellman-Ford，Dijkstra，Floyd-Warshall以及个人理解。 原理简介Bellman-Ford算法Bellman-Ford算法是求单源最短路的算法，基本原理是通过遍历边来对路径进行松弛操作，松弛操作的原理： 记从起点s出发到顶点i的最短距离为d[i]，则下列等式成立： $$ d[i] = min{d[j]+(从i到j的边的权值)|e=(j,i)\in E} $$ 实现代码如下： 123456789101112131415161718192021222324struct edge &#123; int from, to, cost;&#125;;edge es[MAX_E];int d[MAX_V];int V, E;void shortest_path(int s)&#123; for (int i = 0; i &lt; V; i++) d[i] = INF; d[s] = 0; while (true) &#123; bool update = false; for (int i = 0; i &lt; E; i++) &#123; edge e = es[i]; if (d[e.from] != INF &amp;&amp; d[e.to] &gt; d[e.from] + e.cost ) &#123; d[e.to] = d[e.from] + e.cost; update = true; &#125; &#125; if (!update) break; &#125; &#125; 如果图中存在负圈，则最短路不存在；如果图中不存在从s可达的负圈，那么最短路不会经过同一顶点两次，最短路最多只经过V个顶点，最多通过V-1条边，while循环最多执行V-1次。基于这个性质，我们可以检查图中是否存在负圈。 实现代码如下： 1234567891011121314bool find_negative_loop()&#123; memset(d, 0, sizeof(d)); for (int i = 0; i &lt; V; i++) &#123; for (int j = 0; j &lt; E; j++) &#123; edge e = es[j]; if (d[e.to] &gt; d[e.from] + e.cost ) &#123; d[e.to] = d[e.from] + e.cost; if (i == V - 1) return true; &#125; &#125; &#125; return false;&#125; Dijkstra算法Dijkstra算法也是一种单源最短路算法，但它只适用于没有负边的图。其基本原理是遍历点，先找到最短距离已知的顶点，从该点出发，更新相邻顶点的最短距离，之后不需要再考虑这个最短距离已知的顶点。而最短距离已知的顶点是在未使用过的顶点中距离最小的顶点，这是因为不存在负边，距离不会在之后的更新中变小。 实现代码如下： 12345678910111213141516171819202122232425262728typedef pair&lt;int, int&gt; P;struct edge &#123; int to, cost;&#125;;int V;vector&lt;edge&gt; G[MAX_V];int d[MAX_V];void dijkstra(int s)&#123; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; que; fill(d, d + V, INF); d[s] = 0; que.push(P(0, s)); while(!que.empty()) &#123; P p = que.top(); que.pop(); int v = p.second(); for (int i = 0; i &lt; G[v].size(); i++) &#123; edge e = G[v][i]; if (d[e.to] &gt; d[v] + e.cost) &#123; d[e.to] = d[v] + e.cost; que.push(P(d[e.to], e.to)); &#125; &#125; &#125;&#125; Floyd-Warshall算法这是求解任意两点间最短路问题的算法。我们考虑计算顶点i到j的最短路径，记i到j且经过顶点0~k的最短路的长度为d[k+1][i][j],利用DP的思想，我们需要找到一个状态转移方程：该路径可分为经过一次k顶点和不经过两种情况。当不经过顶点k，d[k+1][i][j]=d[k][i][j]；经过顶点k时，d[k+1][i][j]=d[k][i][k]+d[k][k][j]。所以，d[k+1][i][j]=min(d[k][i][j]，d[k][i][k]+d[k][k][j])，可以简化成d[i][j]=min(d[i][j]，d[i][k]+d[k][j])。 实现代码如下： 1234567891011int d[MAX_V][MAX_V];int V;void warshall_floyd()&#123; for (int k = 0; k &lt; V; k++) &#123; for (int i = 0; i &lt; V; i++) &#123; for (int j = 0; j &lt; V; j++) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); &#125; &#125;&#125; 路径还原对于Bellman-Ford和Dijkstra算法，可以采用前趋节点来还原路径，d[j]=d[k]+cost[k][j]中，顶点k就是顶点j的前趋，用prev[j]记录最短路上顶点j的前趋，当路径更新时，更新prev[j]=k即可。 实现代码如下： 123456789int prev[MAX_V];vector&lt;int&gt; get_patch(int t)&#123; vector&lt;int&gt; path; for (; t != -1; t = prev[t]) path.push_back(t); reverse(path.begin(), path.end()); return path;&#125; 对于Floyd-Warshall算法，可以用path[i][j]记录i到j路径上经过的最后一个点，当路径更新时，更新path[i][j]=path[i][k]即可。]]></content>
      <categories>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>Bellman-Ford</tag>
        <tag>Dijkstra</tag>
        <tag>Floyd-Warshall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2019%2F05%2F18%2FDisjoint-Set%2F</url>
    <content type="text"><![CDATA[本文主要介绍了并查集的原理以及代码实现。 原理简介并查集是一种用来管理元素分组情况的数据结构，可以高效地执行如下操作： 查询元素a和元素b是否属于同一组 合并元素a和元素b所在的组 并查集中每个元素对应一个节点，每个组对应一棵树。 注意：并查集中的元素均是有联系的，即只要有关联的元素就会被分到同一集合中 合并操作将一个组的根向另一个组的根连边即可。 查询操作从查询节点沿着树往上走，查询包含该节点的树的根，如果两个节点的根相同，则属于同一组。 优化——路径压缩如果高的树不断向低的树合并，那么就会发生退化，近似变成一个链表，为了避免这种情况，采取一些优化操作进行路径压缩。 对于每棵树，记录这棵树的高度 合并时，高度小的树向高度大的树连边 在查询过程中向上经过的所有节点，都改为直接连到根节点 代码实现1234567891011121314151617181920212223242526272829303132333435int par[MAX_N];int rank[MAX_N];void init(int n)&#123; for (int i = 0; i &lt; n; i++) &#123; par[i] = i; rank[i] = 0; &#125;&#125;int find(int x)&#123; if (par[x] == x) return x; return par[x] = find(par[x]);&#125;void unite(int x, int y)&#123; x = find(x); y = find(y); if (x == y) return; if (rank[x] &lt; rank[y]) &#123; par[x] = y; &#125; else &#123; par[y] = x; if (rank[x] == rank[y]) rank[x]++; &#125;&#125;bool same(int x, int y)&#123; return find(x) == find(y);&#125; 实例讲解食物链（POJ 1182）Description 动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B，B吃C，C吃A。现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。有人用两种说法对这N个动物所构成的食物链关系进行描述：第一种说法是”1 X Y”，表示X和Y是同类。第二种说法是”2 X Y”，表示X吃Y。此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。1） 当前的话与前面的某些真的话冲突，就是假话；2） 当前的话中X或Y比N大，就是假话；3） 当前的话表示X吃X，就是假话。你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。 Input 第一行是两个整数N和K，以一个空格分隔。以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。若D=1，则表示X和Y是同类。若D=2，则表示X吃Y。 Output 只有一个整数，表示假话的数目。 这道题是一道经典的并查集题目，该题难点在于元素之间的关系有两种：同类和捕食。不能想当然地按照A、B、C三种动物来分类，因为并查集中只要有联系就会被分为一组，如何巧妙地维护这两种关系是解决问题的关键。 思路一：改变元素一个动物只有三种情况：A、B、C，既然根据所给信息无法确定某一动物到底属于哪一种动物，那么不妨将这三种情况均记录下来，即对于每只动物i创建三个元素i-A，i-B，i-C，并用这3*N个元素建立并查集，并查集里的每一个组都代表组内所有元素代表的情况都同时发生或不发生，若x和y属于同一种类，合并x-A和y-A、x-B和y-B、x-C和y-C;若x吃y，则合并x-A和y-B、x-B和y-C、x-C和y-A。在合并之前先判断是否会产生矛盾即可判断当前信息是否正确。 实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;using namespace std;#define MAX_N 5000*3#define MAX_K 100000int N, K;int T[MAX_K], X[MAX_K], Y[MAX_K];int par[MAX_N];int rank[MAX_N];void init(int n)&#123; for (int i = 0; i &lt; n; i++) &#123; par[i] = i; rank[i] = 0; &#125;&#125;int find(int x)&#123; if (par[x] == x) return x; return par[x] = find(par[x]);&#125;void unite(int x, int y)&#123; x = find(x); y = find(y); if (x == y) return; if (rank[x] &lt; rank[y]) &#123; par[x] = y; &#125; else &#123; par[y] = x; if (rank[x] == rank[y]) rank[x]++; &#125;&#125;bool same(int x, int y)&#123; return find(x) == find(y);&#125;int main()&#123; scanf("%d %d", &amp;N, &amp;K); for (int i = 0; i &lt; K; i++) &#123; scanf("%d %d %d", &amp;T[i], &amp;X[i], &amp;Y[i]); &#125; init(N * 3); int ans = 0; for (int i = 0; i &lt; K; i++) &#123; int t = T[i]; int x = X[i] - 1, y = Y[i] - 1; if (x &lt; 0 || N &lt;= x || y &lt; 0 || N &lt;= y) &#123; ans++; continue; &#125; if (t == 1) &#123; if (same(x, y + N) || same(x, y + 2 * N)) ans++; else &#123; unite(x, y); unite(x + N, y + N); unite(x + 2 * N, y + 2 * N); &#125; &#125; else &#123; if (same(x, y) || same(x, y + 2 * N)) ans++; else &#123; unite(x, y + N); unite(x + N, y + 2 * N); unite(x + 2 * N, y); &#125; &#125; &#125; printf("%d\n", ans);&#125; 思路二：带权并查集维护的两种关系可以用节点上所带的权值来表示，我们可以把这2个元素之间的关系量转化为一个偏移量，用一个relation[N]数组来记录每个节点到其根节点的偏移量: x-&gt;y 偏移量0时 x和y同类 x-&gt;y 偏移量1时 x被y吃 x-&gt;y 偏移量2时 x吃y 只需要在查询和合并节点时，更新节点到根节点的偏移量即可。只要注意，更新偏移量类似向量加减法，具有方向性。 实现代码略。]]></content>
      <categories>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS & BFS]]></title>
    <url>%2F2019%2F05%2F17%2FDFS%26BFS%2F</url>
    <content type="text"><![CDATA[本文主要介绍了穷竭搜索的两个算法DFS和BFS及它们的实现代码。 原理简介深度优先搜索（DFS）是从某个状态开始，不断地转移到下一个状态，直到“底部”，然后回退到上一个状态，继续搜索该状态可转移的其他状态，不断重复以上过程，得到最终解。一般采用递归函数实现。 宽度优先搜索（BFS）是先搜索离当前状态最近的状态，再搜索次近一点的状态……深度优先搜索类似利用栈计算的方式，将栈顶能转移的状态入栈，直到无可转移状态后再出栈；宽度优先搜索则类似利用队列计算的方式，将当前状态可转移的最近的状态依次加入队列，再从队列前端取出状态，然后将该状态可以转移但未访问过的状态加入队列……其代码实现也正是利用了C++中的queue。 实例讲解Lake Counting（POJ No.2386）Description Due to recent rains, water has pooled in various places in Farmer John’s field, which is represented by a rectangle of N x M (1 &lt;= N &lt;= 100; 1 &lt;= M &lt;= 100) squares. Each square contains either water (‘W’) or dry land (‘.’). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors. Input Line 1: Two space-separated integers: N and M Lines 2..N+1: M characters per line representing one row of Farmer John’s field. Each character is either ‘W’ or ‘.’. The characters do not have spaces between them. Output Line 1: The number of ponds in Farmer John’s field. 只要从任意W开始，用.代替，穷竭搜索其邻接的W，并用.代替，直到图中不存在W为止，此时调用DFS搜索的次数就是答案。 实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;using namespace std;#define MAX_N 100#define MAX_M 100int N, M;char field[MAX_N + 1][MAX_M + 1];void dfs(int x, int y)&#123; field[x][y] = '.'; for (int dx = -1; dx &lt;= 1; dx++) &#123; for (int dy = -1; dy &lt;= 1; dy++) &#123; int nx = x + dx, ny = y + dy; if (0 &lt;= nx &amp;&amp; nx &lt; N &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; M &amp;&amp; field[nx][ny] == 'W') dfs(nx, ny); &#125; &#125;&#125;int main()&#123; int res = 0; scanf("%d %d", &amp;N, &amp;M); for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; M; j++) &#123; scanf("%c", &amp;field[i][j]); &#125; getchar(); &#125; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; M; j++) &#123; if (field[i][j] == 'W') &#123; dfs(i, j); res++; &#125; &#125; &#125; printf("%d\n",res);&#125; 迷宫的最短路径给定一个大小为N*M的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四格的通道移动。请求出从起点到终点所需的最小步数。 题目要求最短路径，很容易想到用BFS，因为它最先搜索距离最近的点，我们只需要从起点开始搜索，用一个d[N][M]数组把各点到起点的距离保存起来，就能求出起点到终点的最短距离。 实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;utility&gt;#include &lt;algorithm&gt;using namespace std;#define MAX_N 100#define MAX_M 100const int INF = 100000000;typedef pair&lt;int, int&gt; P;int dx[4] = &#123;1, 0, -1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;; //4个方向移动的向量char maze[MAX_N + 1][MAX_M + 1];int N, M;int sx, sy;int gx, gy;int d[MAX_N + 1][MAX_M + 1];int bfs()&#123; queue&lt;P&gt; que; for (int i = 0; i &lt; N; i++) fill(d[i], d[i] + M, INF); que.push(P(sx, sy)); d[sx][sy] = 0; while (que.size()) &#123; P p = que.front(); que.pop(); if (p.first == gx &amp;&amp; p.second == gy) break; for (int i = 0; i &lt; 4; i++) &#123; int nx = p.first + dx[i], ny = p.second + dy[i]; if (0 &lt;= nx &amp;&amp; nx &lt; N &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; M &amp;&amp; maze[nx][ny] != '#' &amp;&amp; d[nx][ny] == INF) &#123; que.push(P(nx, ny)); d[nx][ny] = d[p.first][p.second] + 1; &#125; &#125; &#125; return d[gx][gy];&#125;int main()&#123; scanf("%d %d", &amp;N, &amp;M); for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; M; j++) &#123; scanf("%c", &amp;maze[i][j]); if (maze[i][j] == 'S') &#123; sx = i; sy = j; &#125; if (maze[i][j] == 'G') &#123; gx = i; gy = j; &#125; &#125; getchar(); &#125; int res = bfs(); printf("%d\n",res);&#125;]]></content>
      <categories>
        <category>DFS&amp;BFS</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2019%2F05%2F16%2FDP%2F</url>
    <content type="text"><![CDATA[简单来说，动态规划即记忆化搜索。本文简单介绍了动态规划的原理及代码实现。 原理简介对于某些问题，进行穷竭搜索并不是最优解，某些节点会被多次计算，这导致时间、空间复杂度的增加。动态规划就是用来将这些结果记录下来，能大大降低复杂度的算法。要用动态规划解决问题必须先对问题的状态进行合理的假设，建立状态转移方程，确定边界。 一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！ 每个阶段只有一个状态-&gt;递推； 每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心； 每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索； 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。 实例讲解01背包问题有n个重量和价值分别为wi，vi的物品。从这些物品中挑选出总重量不超过W的物品，求所有挑选方案中价值总和的最大值。 这里，我们可以定义： $$ dp[i+1][j]：从0到i这i+1个物品中选出重量不超过j的物品时总价值的最大值 $$ 因此，两个状态的转移就有两种可能：选第i个物品；不选第i个物品。得到状态转移方程： $$dp[i+1][j] =\begin{cases}dp[i][j] &amp; (j&lt;w[i]) \\max(dp[i][j],dp[i][j-w[i]]+v[i]) &amp; (其他)\end{cases}$$ 实现代码如下： 12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define MAX_N 100#define MAX_W 10000int dp[MAX_N + 1][MAX_W + 1];int main()&#123; int n, W; int w[MAX_N + 1], v[MAX_N + 1]; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf("%d %d", &amp;w[i], &amp;v[i]); &#125; scanf("%d", &amp;W); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= W; j++) &#123; if (j &lt; w[i]) dp[i + 1][j] = dp[i][j]; else dp[i + 1][j] = max(dp[i][j], dp[i][j - w[i]] + v[i]); &#125; &#125; printf("%d\n", dp[n][W]);&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
